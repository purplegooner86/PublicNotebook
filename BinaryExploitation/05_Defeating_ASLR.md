# Defeating ASLR

Address Space Layout Randomization is a protection technique to prevent the exploitation of vulnerabilities related to memory corruption.  
It does so by randomizing the virtual memory mapping of the components of a binary such as the address of stack, heap, and libraries, etc.  
Specifically `ASLR 1` means the positions of the stack, virtual dynamic shared object (VDSO) page, and shared memory regions are randomized  
`ASLR 2` means the positions of the stack, VDSO page, shared memory regions, and data segment are randomized  
`echo value | sudo tee /proc/sys/kernel/randomize_va_space` changes ASLR setting  

<br />

## GOT and PLT

Libraries are pieces of code that can be shared between programs  
There are two ways a program knows the address of a function in a library: *static linking* and *dynamic linking*  
<br>
Statically linked binaries contain all of the code in the libraries that it uses in the final executable  
Consider having hundreds of statically linked C programs running on a linux system and all of them use libc. This means each of the programs will have a copy of libc and load it in the memory. This is a big waste of storage.  
In dynamic linking, only minimal information about the libraries are included in the final executable.  
Libraries are loaded at load time or runtime, and the function addresses are resolved.  
<br>
`ldd` shows us the dynamic binaries referenced needed by a binary  
Example: `ldd vulnC`  
Note: `libc.so.6` is usually a symlink to a `libc-version.so`. These two files are usually in the same directory as eachother libc-version.so is the actual libc
`ls -la /lib/x86_64/ | grep libc.so.6` will show you the linked libc version  
<br>
During compilation, we don't know the function addresses in a shared library  
This is because any update on the shared library that changes the addresses of functions would break all of the programs that use it  
Resolving the addresses of shared libraries during runtime is done by the linker (ld-linux.so) and this process is called relocation  
Relocations are basically dummy entries in executables that are later filled at link time or runtime.  

ELF files are made up of different sections. Sections such as .text, .data, .rodata, and .bss  
There are also sections used during relocations, namely: .got, .plt, .got.plt, .plt.got  

**.got (Global Offset Table):** This section is where the linker puts the addresses of resolved global variables  
**.plt (Procedure Linking Table):** This section contains stubs of code that either jump to the right address or call the linker to resolve the address  
**.got.plt (GOT for PLT):** This section either contains the right address of the resolved function, or points back to .plt to trigger the lookup to resolve the address  
<br>
What you need to know is that when a function is first called (ie. putchar):

1. it jumps to an address in .plt (putchar@plt)
2. which jumps to an address saved in GOT for PLT (.got.plt)
3. which at this time does not contain the right address and points back to the next instruction in .plt
4. which will actually do the lookup and patch the address in .got.plt with the right address of the function (putchar@GLIBC) and call it
    The next time the function is called, the .got.plt entry in the third step will contain the right address and the lookup is not triggered

All of this makes it possible to have position independent code (PIC) which means code without using absolute addresses  
This in turn makes it possible for text sections of shared libraries to be loaded into the memory once and then mapped to virtual address spaces of processes  

## Exploitation Strategy

ASLR randomizes the base address of shared libraries  
Addresses of instructions in these libraries relative to the base address stay the same  
Offsets of functions from the base address of libraries are available to us and are fixed.  
First we will leak the address of one of the libc functions in the GOT, and use that to find the libc base address in the current program  
We will do this by subtracting the offset of the same function in libc to find the currentÂ  base address of the loaded libc library  
Then, we can use this base address to calculate the address of any libc function we want

## Exploitation

This is describing the exploit here: [5_defeatASLR](./fundamental_examples/5_defeatASLR/exploit.py)  

The target file calls `puts`  
In the first stage of our exploit we will:

1. Use a pop rdi gadget to pop the address of the puts entry in GOT into rdi
2. Use the address of puts in the PLT to call puts (which uses rdi as its parameter)
3. Use the address of the main function to essentially loop back to the start of the binary

Once we complete this stage of the exploit, we run it several times and see the address of puts in GLIBC changing each time:  
Leaked puts@GLIBC: `0x7f3048a94420`  
Leaked puts@GLIBC: `0x7f2f4ee35420`  
Leaked puts@GLIBC: `0x7f6d88b47420`  
<br>
Notice how the last three, and first two digits of the address do not change. I don't know exacty why that is, but it is a good sign (This was not the case when it was not working earlier)  
If that is not the case, there is a good chance you are stripping the leak incorrectly  

We then subtract the libc address of printf from this leaked value, and are left with the base address of libc  

We can then use `ldd` and `readelf` to determine the offsets in libc that useful functions are at  
In this example, we find a string to /bin/sh and the address of system
In conjunction with pop rdi gadget and some padding, we can pop a shell