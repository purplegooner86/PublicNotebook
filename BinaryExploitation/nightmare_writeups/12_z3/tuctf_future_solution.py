import z3

# future is a 32-bit dynamically linked executable
# We are given source code, future.c

# The executable scans in a string of user input
# then it performs a complex algorithm on that input to generate an authorization string
# it then checks that authorization string against a set string

# We control the input, know the algorithm applied to our input, and know the target result, so z3 is a good option

# This one ends up being interesting, because there are thousands of strings that could actually serve as the flag
# I wrote code to get all of those possible solutions in order to better understand our results
# Then, we add constraints based on the known format of the flag for the ctf and are able to narrow it down to 1 result

# the executable scans in 25 bytes of user input
# It then appends a '\0' to the input
# then it checks to make sure the user in does not contain any null bytes before the last one

# creates a 5x5 matrix
# We can just mimic the function to create a similar matrix:

def create_matrix(user_in):
    mat = []
    for i in range(5):
        inner = [None] * 5
        mat.append(inner)

    for i in range(25):
        m = (i * 2) % 25
        f = (i * 7) % 25
        mat[int(m/5)][m%5] = user_in[f]
    
    return mat


# then a length 18 auth string is generated using those matrix values
# We can again just copy the algorithm for its generation:
def gen_auth(mat):
    auth = [None] * 18

    auth[0] = mat[0][0] + mat[4][4]
    auth[1] = mat[2][1] + mat[0][2]
    auth[2] = mat[4][2] + mat[4][1]
    auth[3] = mat[1][3] + mat[3][1]
    auth[4] = mat[3][4] + mat[1][2]
    auth[5] = mat[1][0] + mat[2][3]
    auth[6] = mat[2][4] + mat[2][0]
    auth[7] = mat[3][3] + mat[3][2] + mat[0][3]
    auth[8] = mat[0][4] + mat[4][0] + mat[0][1]
    auth[9] = mat[3][3] + mat[2][0]
    auth[10] = mat[4][0] + mat[1][2]
    auth[11] = mat[0][4] + mat[4][1]
    auth[12] = mat[0][3] + mat[0][2]
    auth[13] = mat[3][0] + mat[2][0]
    auth[14] = mat[1][4] + mat[1][2]
    auth[15] = mat[4][3] + mat[2][3]
    auth[16] = mat[2][2] + mat[0][2]
    auth[17] = mat[1][1] + mat[4][1]

    return auth

# Then, that auth string is compared to a desired output string:
desired_output = [0x8b, 0xce, 0xb0, 0x89, 0x7b, 0xb0, 0xb0, 0xee, 0xbf, 0x92, 0x65, 0x9d, 0x9a, 0x99, 0x99, 0x94, 0xad, 0xe4]


# Setting up our input to z3
# We give 25 8-bit values of user-input
input = []
for i in range(25):
    b = z3.BitVec("%s" % i, 8)
    input.append(b)

z_solver = z3.Solver()

out_auth = gen_auth(create_matrix(input))
for i in range(18):
    z_solver.add( out_auth[i] == desired_output[i] )
    z_solver.add( input[i] > 32 ) # All of the ascii characters less and equal to 32 are not readable characters
    z_solver.add( input[i] != 127) # ascii 127 is DEL

# There end up being thousands of solutions to this system
# All of the flags for this ctf started with 'TUCTF{' and ended with '}'
# We can narrow down our results by enforcing those constraints

z_solver.add(input[0] == ord('T'))
z_solver.add(input[1] == ord('U'))
z_solver.add(input[2] == ord('C'))
z_solver.add(input[3] == ord('T'))
z_solver.add(input[4] == ord('F'))
z_solver.add(input[5] == ord('{'))
z_solver.add(input[24] == ord('}'))

# And with those constraints, we are left with only one flag: TUCTF{5y573m5_0f_4_d0wn!}

if (z_solver.check() != z3.sat):
    print("No solution")

counter = 0 # Setting max number of solutions to write to file so things don't get out of hand

# Our final result doesn't need to loop through all of the possible flags, because there ends up being only one,
# But prior versions, to narrow down our results needed to
# This code prints up to 1000 solutions to the system by adding new constraints after every time it generates a potential flag
# The new constraints just say that one of the inputs must change

while z_solver.check() == z3.sat and counter < 1000: # find a maximum of 1000 solutions
    counter += 1
    if z_solver.check() == z3.sat:
        solution = z_solver.model()
        flag = b''
        for i in range(25):
            a = int(str(solution[input[i]]))
            flag += chr(a).encode()
        print(flag)
        
        # Add more constraints to the model
        block = []
        for d in solution:
            c = d()
            block.append(c != solution[d])
        z_solver.add(z3.Or(block))