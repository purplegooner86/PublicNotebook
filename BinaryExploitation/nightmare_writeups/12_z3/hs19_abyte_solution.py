import z3

# a-byte is a 64-bit dynamically-linked executable
# It takes 35 1-byte user inputs and runs them through an algorithm and then checks each of them against a desired output

# z3 aka Z3 Theorem Prover is a solver for symbolic logic made by Microsoft Research
# There is a lot too it
# For our sake, if we know the input we control, the algorithm that it is passed through, and the desired end result, z3 can find the solution

# This is the end state that the executable checks our manipulated input against
desiredOutput = [0x69, 0x72, 0x62, 0x75, 0x67, 0x7a, 0x76, 0x31, 0x76, 0x5e, 0x78, 0x31, 0x74, 0x5e, 0x6a, 0x6f, 0x31, 0x76, 0x5e, 0x65, 0x35, 0x5e, 0x76, 0x40, 0x32, 0x5e, 0x39, 0x69, 0x33, 0x63, 0x40, 0x31, 0x33, 0x38, 0x7c]


# Designate the input z3 will have control of
# In this case we give 35 8-bit values to the executable
# Create a list of 35 8-bit vectors
inp = []
for i in range(0, 35):
    byte = z3.BitVec("%s" % i, 8)
    inp.append(byte)

z = z3.Solver()

# We are adding constraints to our solution
# Every 8-bit vector xor'd with 1 must equal its corresponding value in desiredOutput
# If its impossible for n ^ 1 to equal i for any 8-bit n and i in desiredOutput, the solution will fail
for i in range(0, 35):
    z.add((inp[i] ^ 1) == desiredOutput[i])

# Check if z3 can solve it. and if it can, print out the solution
if z.check() == z3.sat:
    print (f"Condition is Satisfied: {str(z.check())}")
    solution = z.model()
    flag = ""
    for i in range(0, 35):
        flag += chr(int(str(solution[inp[i]])))
    print(flag)
else:
    print(f"Condition is not satisfied: {str(z.check())}")
