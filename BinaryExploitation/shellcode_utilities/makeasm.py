import os
import sys
import subprocess

def usage():
    print("Usage: makeasm <bits> <option> <filename.asm>")
    print("Compiles .asm files to object and executable files")
    print("File In: filename.asm")
    print("Files Out:")
    print("     filename # executable for testing")
    print("     filename.bin # binary opcodes")
    print("     filename.o # unlinked object file")
    print("     filename.txt # ascii opcodes")
    print("     <bits> should be either '32' or '64'")
    print("     Use 'clean' option to remove all outputs except executable and .txt")

def errorout(cmd=''):
    if(cmd):
        print(f"Error with command: {cmd}")
        print("Quitting...")
    else:
        print("ERROR. Unable to continue.")
    sys.exit(1)

if (len(sys.argv) < 3):
    usage()
    sys.exit()

if (sys.argv[1] == "32"):
    bits64 = False
elif (sys.argv[1] == "64"):
    bits64 = True
else:
    print(f"Un-recognised bits option: {sys.argv[1]}")
    usage()
    sys.exit() 

clean = False
firstFileIndex = 2
if (sys.argv[2] == "clean"):
    clean = True
    firstFileIndex = 3

def checkBadChars(opcodes):
    badcodes = [b'00']
    for badcode in badcodes:
        if (badcode in opcodes):
            index = opcodes.index(badcode)
            print(f"WARNING - Contains Bytes: {badcode} at index {index}")

def processASM(filename):
    if (not filename[-4:] == ".asm" or not os.path.isfile(filename)):
        print(f"Error: unable to find .asm file {filename}")
        usage()
        sys.exit(1)
    
    execname = os.path.basename(filename)[:-4]

    # 1) Compile .asm -> .o
    if bits64:
        cmd = f"nasm -f elf64 {filename}"
    else:
        cmd = f"nasm -f elf {filename}"
    val = os.system(cmd)
    if(val):
        errorout(cmd)
    
    # 2) Link .o -> executable
    if bits64:
        cmd = f"ld -o {execname} {execname}.o"
    else:
        cmd = f"ld -m elf_i386 -o {execname} {execname}.o"
    val = os.system(cmd)
    if(val):
        errorout(cmd)

    # 3) use objdump to read hex opcodes
    p = subprocess.Popen(["objdump", "-d", execname], stdout=subprocess.PIPE)
    out, err = p.communicate()
    if(err):
        cmd = f"objdump -d {execname}"
        errorout(cmd)

    lines = out.split(b'\n')

    # 4) Parse the opcodes from these lines
    opcodes = []
    for line in lines:
        if (line and (line[0] == 32)): # 32 is the ' ' character
            tmp = line.split(b'\t')[1].strip()
            opcodes.extend(tmp.split())
    
    # 5) Generate a string output of the opcodes
    opcodestr = ""
    for e in opcodes:
        opcodestr += "\\x" + e.decode()
    print(f"{filename} opcodes:")
    checkBadChars(opcodes)
    print(opcodestr)
    print("")

    # 6) Save ascii opcodes to a file
    textfile = f"{execname}.txt"
    f = open(textfile, "w")
    f.write(opcodestr)
    f.write("\n")
    f.close()

    # 7) Save binary opcodes to a file
    binfile = f"{execname}.bin"
    f = open(binfile, 'wb')
    for opcode in opcodes:
        f.write(opcode)
    f.close()

    if clean:
        os.system(f"rm {execname}.bin")
        os.system(f"rm {execname}.o")

for fname in sys.argv[firstFileIndex:]:
    processASM(fname)