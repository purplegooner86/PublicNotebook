# Defeating PIE

This follows the exploit here: [8_pie](./fundamental_examples/8_pie/exploit.py)    
This is a 64-bit dynamically linked executable with Full RELRO, A gdb stack canary, NX enabled, PIE enabled, and ASLR turned on  
That's like all the protections!  
Full RELRO means we can't overwrite the got with printf exploit. And PIE and ASLR mean we are going to have to leak some stuff to calculate addresses

## PIE Exploitation

PIE essentially randomizes the address space of everything in the executable  
While ASLR randomizes the addresses of a couple things; most importantly the base address of libc, and the address of the stack, PIE essentially randomizes the base addresses of everything else  
This means the locations of our gadgets are no longer fixed, nor got addresses, nor plt addresses  
<br>
We can defeat PIE with a printf format string infoleak.  
We leak the return address of the call to vuln_func, and subtract the known offset of that instruction to find the pie base address of the executable  
The math to figure out what `%$p` value we need to print is shown in the exploit  

## The Rest of the Exploit

The rest of the exploit involves  
1. leaking the canary value with printf format string
2. making a call to printf plt to leak printf got to defeat aslr
3. looping back over to an instruction in main
4. Sending a rop chain to invoke `system('/bin/sh')`

See the exploit for more details